// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: csi.proto

/*
	Package csilvm is a generated protocol buffer package.

	It is generated from these files:
		csi.proto

	It has these top-level messages:
		GetSupportedVersionsRequest
		GetSupportedVersionsResponse
		Version
		GetPluginInfoRequest
		GetPluginInfoResponse
		CreateVolumeRequest
		CreateVolumeResponse
		VolumeCapability
		CapacityRange
		VolumeInfo
		AccessMode
		VolumeID
		VolumeMetadata
		DeleteVolumeRequest
		DeleteVolumeResponse
		ControllerPublishVolumeRequest
		ControllerPublishVolumeResponse
		NodeID
		PublishVolumeInfo
		ControllerUnpublishVolumeRequest
		ControllerUnpublishVolumeResponse
		ValidateVolumeCapabilitiesRequest
		ValidateVolumeCapabilitiesResponse
		ListVolumesRequest
		ListVolumesResponse
		GetCapacityRequest
		GetCapacityResponse
		ControllerGetCapabilitiesRequest
		ControllerGetCapabilitiesResponse
		ControllerServiceCapability
		NodePublishVolumeRequest
		NodePublishVolumeResponse
		NodeUnpublishVolumeRequest
		NodeUnpublishVolumeResponse
		GetNodeIDRequest
		GetNodeIDResponse
		ProbeNodeRequest
		ProbeNodeResponse
		NodeGetCapabilitiesRequest
		NodeGetCapabilitiesResponse
		NodeServiceCapability
		Error
*/
package csilvm

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AccessMode_Mode int32

const (
	UNKNOWN AccessMode_Mode = 0
	// Can be published as read/write at one node at a time.
	SINGLE_NODE_WRITER AccessMode_Mode = 1
	// Can be published as readonly at one node at a time.
	SINGLE_NODE_READER_ONLY AccessMode_Mode = 2
	// Can be published as readonly at multiple nodes simultaneously.
	MULTI_NODE_READER_ONLY AccessMode_Mode = 3
	// Can be published at multiple nodes simultaneously. Only one of
	// the node can be used as read/write. The rest will be readonly.
	MULTI_NODE_SINGLE_WRITER AccessMode_Mode = 4
	// Can be published as read/write at multiple nodes simultaneously.
	MULTI_NODE_MULTI_WRITER AccessMode_Mode = 5
)

var AccessMode_Mode_name = map[int32]string{
	0: "UNKNOWN",
	1: "SINGLE_NODE_WRITER",
	2: "SINGLE_NODE_READER_ONLY",
	3: "MULTI_NODE_READER_ONLY",
	4: "MULTI_NODE_SINGLE_WRITER",
	5: "MULTI_NODE_MULTI_WRITER",
}
var AccessMode_Mode_value = map[string]int32{
	"UNKNOWN":                  0,
	"SINGLE_NODE_WRITER":       1,
	"SINGLE_NODE_READER_ONLY":  2,
	"MULTI_NODE_READER_ONLY":   3,
	"MULTI_NODE_SINGLE_WRITER": 4,
	"MULTI_NODE_MULTI_WRITER":  5,
}

func (AccessMode_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptorCsi, []int{10, 0} }

type ControllerServiceCapability_RPC_Type int32

const (
	UNKNOWN                  ControllerServiceCapability_RPC_Type = 0
	CREATE_DELETE_VOLUME     ControllerServiceCapability_RPC_Type = 1
	PUBLISH_UNPUBLISH_VOLUME ControllerServiceCapability_RPC_Type = 2
	LIST_VOLUMES             ControllerServiceCapability_RPC_Type = 3
	GET_CAPACITY             ControllerServiceCapability_RPC_Type = 4
)

var ControllerServiceCapability_RPC_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "CREATE_DELETE_VOLUME",
	2: "PUBLISH_UNPUBLISH_VOLUME",
	3: "LIST_VOLUMES",
	4: "GET_CAPACITY",
}
var ControllerServiceCapability_RPC_Type_value = map[string]int32{
	"UNKNOWN":                  0,
	"CREATE_DELETE_VOLUME":     1,
	"PUBLISH_UNPUBLISH_VOLUME": 2,
	"LIST_VOLUMES":             3,
	"GET_CAPACITY":             4,
}

func (ControllerServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{29, 0, 0}
}

type NodeServiceCapability_RPC_Type int32

const (
	UNKNOWN NodeServiceCapability_RPC_Type = 0
)

var NodeServiceCapability_RPC_Type_name = map[int32]string{
	0: "UNKNOWN",
}
var NodeServiceCapability_RPC_Type_value = map[string]int32{
	"UNKNOWN": 0,
}

func (NodeServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{40, 0, 0}
}

type Error_GeneralError_GeneralErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `GeneralErrorCode` code that an older CSI client is not aware
	// of, the client will see this code (the default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN Error_GeneralError_GeneralErrorCode = 0
	// Indicates that an undefined error occurred. More human-readable
	// information MAY be provided in the `error_description` field.
	// The `caller_must_not_retry` field MUST be set appropriately by
	// the Plugin to provide callers expected recovery behavior.
	//
	// Recovery behavior: Caller MAY retry (with exponential backoff),
	// if `caller_must_not_retry` is set to false. Otherwise, the
	// caller MUST not reissue the same request.
	UNDEFINED Error_GeneralError_GeneralErrorCode = 1
	// Indicates that the version specified in the request is not
	// supported by the Plugin. The `caller_must_not_retry` field MUST
	// be set to true.
	//
	// Recovery behavior: Caller MUST NOT retry; caller SHOULD call
	// `GetPluginInfo` to discover which CSI versions the Plugin
	// supports.
	UNSUPPORTED_REQUEST_VERSION Error_GeneralError_GeneralErrorCode = 2
	// Indicates that a required field is missing from the request.
	// More human-readable information MAY be provided in the
	// `error_description` field. The `caller_must_not_retry` field
	// MUST be set to true.
	//
	// Recovery behavior: Caller MUST fix the request by adding the
	// missing required field before retrying.
	MISSING_REQUIRED_FIELD Error_GeneralError_GeneralErrorCode = 3
)

var Error_GeneralError_GeneralErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "UNDEFINED",
	2: "UNSUPPORTED_REQUEST_VERSION",
	3: "MISSING_REQUIRED_FIELD",
}
var Error_GeneralError_GeneralErrorCode_value = map[string]int32{
	"UNKNOWN":                     0,
	"UNDEFINED":                   1,
	"UNSUPPORTED_REQUEST_VERSION": 2,
	"MISSING_REQUIRED_FIELD":      3,
}

func (Error_GeneralError_GeneralErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 0, 0}
}

type Error_CreateVolumeError_CreateVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `CreateVolumeErrorCode` code that an older CSI client is not
	// aware of, the client will see this code (the default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN Error_CreateVolumeError_CreateVolumeErrorCode = 0
	// Indicates that the call is either not implemented by the Plugin
	// or disabled in the Plugin’s current mode of operation.
	//
	// Recovery behavior: Caller MUST not retry; caller MAY call
	// `ControllerGetCapabilities` or `NodeGetCapabilities` to discover
	// Plugin capabilities.
	CALL_NOT_IMPLEMENTED Error_CreateVolumeError_CreateVolumeErrorCode = 1
	// Indicates that there is a already an operation pending for the
	// specified volume. In general the Cluster Orchestrator (CO) is
	// responsible for ensuring that there is no more than one call
	// “in-flight” per volume at a given time. However, in some
	// circumstances, the CO MAY lose state (for example when the CO
	// crashes and restarts), and MAY issue multiple calls
	// simultaneously for the same volume. The Plugin, SHOULD handle
	// this as gracefully as possible, and MAY return this error code
	// to reject secondary calls.
	//
	// Recovery behavior: Caller SHOULD ensure that there are no other
	// calls pending for the specified volume, and then retry with
	// exponential back off.
	OPERATION_PENDING_FOR_VOLUME Error_CreateVolumeError_CreateVolumeErrorCode = 2
	// Indicates that the specified volume name is not allowed by the
	// Plugin. More human-readable information MAY be provided in the
	// `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the name before retrying.
	INVALID_VOLUME_NAME Error_CreateVolumeError_CreateVolumeErrorCode = 3
	// Indicates that the capacity range is not allowed by the Plugin.
	// More human-readable information MAY be provided in the
	// `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the capacity range before //
	// retrying.
	UNSUPPORTED_CAPACITY_RANGE Error_CreateVolumeError_CreateVolumeErrorCode = 4
	// Indicates that a volume corresponding to the specified volume
	// name already exists.
	//
	// Recovery behavior: Caller MAY assume the `CreateVolume`
	// call succeeded.
	VOLUME_ALREADY_EXISTS Error_CreateVolumeError_CreateVolumeErrorCode = 5
	// Indicates that a key in the opaque key/value parameters field
	// is not supported by the Plugin. More human-readable information
	// MAY be provided in the `error_description` field. This MAY
	// occur, for example, due to caller error, Plugin version skew, etc.
	//
	// Recovery behavior: Caller MUST remove the unsupported key/value
	// pair from the list of parameters before retrying.
	UNSUPPORTED_PARAMETER_KEY Error_CreateVolumeError_CreateVolumeErrorCode = 6
	// Indicates that a value in one of the opaque key/value pairs
	// parameter contains invalid data. More human-readable
	// information (such as the corresponding key) MAY be provided in
	// the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the invalid value before
	// retrying.
	INVALID_PARAMETER_VALUE Error_CreateVolumeError_CreateVolumeErrorCode = 7
)

var Error_CreateVolumeError_CreateVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "CALL_NOT_IMPLEMENTED",
	2: "OPERATION_PENDING_FOR_VOLUME",
	3: "INVALID_VOLUME_NAME",
	4: "UNSUPPORTED_CAPACITY_RANGE",
	5: "VOLUME_ALREADY_EXISTS",
	6: "UNSUPPORTED_PARAMETER_KEY",
	7: "INVALID_PARAMETER_VALUE",
}
var Error_CreateVolumeError_CreateVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                      0,
	"CALL_NOT_IMPLEMENTED":         1,
	"OPERATION_PENDING_FOR_VOLUME": 2,
	"INVALID_VOLUME_NAME":          3,
	"UNSUPPORTED_CAPACITY_RANGE":   4,
	"VOLUME_ALREADY_EXISTS":        5,
	"UNSUPPORTED_PARAMETER_KEY":    6,
	"INVALID_PARAMETER_VALUE":      7,
}

func (Error_CreateVolumeError_CreateVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 1, 0}
}

type Error_DeleteVolumeError_DeleteVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `DeleteVolumeErrorCode` code that an older CSI client is not
	// aware of, the client will see this code (the default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN Error_DeleteVolumeError_DeleteVolumeErrorCode = 0
	// Indicates that the call is either not implemented by the Plugin
	// or disabled in the Plugin’s current mode of operation.
	//
	// Recovery behavior: Caller MUST not retry; caller MAY call
	// `ControllerGetCapabilities` or `NodeGetCapabilities` to
	// discover Plugin capabilities.
	CALL_NOT_IMPLEMENTED Error_DeleteVolumeError_DeleteVolumeErrorCode = 1
	// Indicates that there is a already an operation pending for the
	// specified volume. In general the Cluster Orchestrator (CO) is
	// responsible for ensuring that there is no more than one call
	// “in-flight” per volume at a given time. However, in some
	// circumstances, the CO MAY lose state (for example when the CO
	// crashes and restarts), and MAY issue multiple calls
	// simultaneously for the same volume. The Plugin, SHOULD handle
	// this as gracefully as possible, and MAY return this error code
	// to reject secondary calls.
	//
	// Recovery behavior: Caller SHOULD ensure that there are no other
	// calls pending for the specified volume, and then retry with
	// exponential back off.
	OPERATION_PENDING_FOR_VOLUME Error_DeleteVolumeError_DeleteVolumeErrorCode = 2
	// Indicates that the specified `VolumeID` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeID` before
	// retrying.
	INVALID_VOLUME_ID Error_DeleteVolumeError_DeleteVolumeErrorCode = 3
	// Indicates that the specified `VolumeMetadata` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeMetadata` before
	// retrying.
	INVALID_VOLUME_METADATA Error_DeleteVolumeError_DeleteVolumeErrorCode = 4
	// Indicates that a volume corresponding to the specified
	// `VolumeID` does not exist.
	//
	// Recovery behavior: Caller SHOULD assume the `DeleteVolume` call
	// succeeded.
	VOLUME_DOES_NOT_EXIST Error_DeleteVolumeError_DeleteVolumeErrorCode = 5
)

var Error_DeleteVolumeError_DeleteVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "CALL_NOT_IMPLEMENTED",
	2: "OPERATION_PENDING_FOR_VOLUME",
	3: "INVALID_VOLUME_ID",
	4: "INVALID_VOLUME_METADATA",
	5: "VOLUME_DOES_NOT_EXIST",
}
var Error_DeleteVolumeError_DeleteVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                      0,
	"CALL_NOT_IMPLEMENTED":         1,
	"OPERATION_PENDING_FOR_VOLUME": 2,
	"INVALID_VOLUME_ID":            3,
	"INVALID_VOLUME_METADATA":      4,
	"VOLUME_DOES_NOT_EXIST":        5,
}

func (Error_DeleteVolumeError_DeleteVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 2, 0}
}

type Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `ControllerPublishVolumeErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 0
	// Indicates that the call is either not implemented by the Plugin
	// or disabled in the Plugin’s current mode of operation.
	//
	// Recovery behavior: Caller MUST not retry; caller MAY call
	// `ControllerGetCapabilities` or `NodeGetCapabilities` to discover
	// Plugin capabilities.
	CALL_NOT_IMPLEMENTED Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 1
	// Indicates that there is a already an operation pending for the
	// specified volume. In general the Cluster Orchestrator (CO) is
	// responsible for ensuring that there is no more than one call
	// “in-flight” per volume at a given time. However, in some
	// circumstances, the CO MAY lose state (for example when the CO
	// crashes and restarts), and MAY issue multiple calls
	// simultaneously for the same volume. The Plugin, SHOULD handle
	// this as gracefully as possible, and MAY return this error code
	// to reject secondary calls.
	//
	// Recovery behavior: Caller SHOULD ensure that there are no other
	// calls pending for the specified volume, and then retry with
	// exponential back off.
	OPERATION_PENDING_FOR_VOLUME Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 2
	// Indicates that the specified `VolumeID` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeID` before
	// retrying.
	INVALID_VOLUME_ID Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 3
	// Indicates that the specified `VolumeMetadata` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeMetadata` before
	// retrying.
	INVALID_VOLUME_METADATA Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 4
	// Indicates that a volume corresponding to the specified
	// `VolumeID` does not exist.
	//
	// Recovery behavior: Caller SHOULD verify that the `VolumeID` is
	// correct and that the volume is accessible and has not been
	// deleted before retrying with exponential back off.
	VOLUME_DOES_NOT_EXIST Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 5
	// Indicates that a volume corresponding to the specified
	// `VolumeID` is already attached to another node and does not
	// support multi-node attach. If this error code is returned, the
	// Plugin MUST also specify the `node_id` of the node the volume
	// is already attached to.
	//
	// Recovery behavior: Caller MAY use the provided `node_ids`
	// information to detach the volume from the other node. Caller
	// SHOULD ensure the specified volume is not attached to any other
	// node before retrying with exponential back off.
	VOLUME_ALREADY_ATTACHED Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 6
	// Indicates that a node corresponding to the specified `NodeID`
	// does not exist.
	//
	// Recovery behavior: Caller SHOULD verify that the `NodeID` is
	// correct and that the node is available and has not been
	// terminated or deleted before retrying with exponential backoff.
	NODE_DOES_NOT_EXIST Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 7
	// Indicates that a volume corresponding to the specified
	// `VolumeID` is already attached to the maximum supported number
	// of nodes and therefore this operation can not be completed
	// until the volume is detached from at least one of the existing
	// nodes. When this error code is returned, the Plugin MUST also
	// specify the `NodeId` of all the nodes the volume is attached
	// to.
	//
	// Recovery behavior: Caller MAY use the provided `node_ids`
	// information to detach the volume from one other node before
	// retrying with exponential backoff.
	MAX_ATTACHED_NODES Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode = 8
)

var Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "CALL_NOT_IMPLEMENTED",
	2: "OPERATION_PENDING_FOR_VOLUME",
	3: "INVALID_VOLUME_ID",
	4: "INVALID_VOLUME_METADATA",
	5: "VOLUME_DOES_NOT_EXIST",
	6: "VOLUME_ALREADY_ATTACHED",
	7: "NODE_DOES_NOT_EXIST",
	8: "MAX_ATTACHED_NODES",
}
var Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                      0,
	"CALL_NOT_IMPLEMENTED":         1,
	"OPERATION_PENDING_FOR_VOLUME": 2,
	"INVALID_VOLUME_ID":            3,
	"INVALID_VOLUME_METADATA":      4,
	"VOLUME_DOES_NOT_EXIST":        5,
	"VOLUME_ALREADY_ATTACHED":      6,
	"NODE_DOES_NOT_EXIST":          7,
	"MAX_ATTACHED_NODES":           8,
}

func (Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 3, 0}
}

type Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `ControllerUnpublishVolumeErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 0
	// Indicates that the call is either not implemented by the Plugin
	// or disabled in the Plugin’s current mode of operation.
	//
	// Recovery behavior: Caller MUST not retry; caller MAY call
	// `ControllerGetCapabilities` or `NodeGetCapabilities` to
	// discover Plugin capabilities.
	CALL_NOT_IMPLEMENTED Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 1
	// Indicates that there is a already an operation pending for the
	// specified volume. In general the Cluster Orchestrator (CO) is
	// responsible for ensuring that there is no more than one call
	// “in-flight” per volume at a given time. However, in some
	// circumstances, the CO MAY lose state (for example when the CO
	// crashes and restarts), and MAY issue multiple calls
	// simultaneously for the same volume. The Plugin, SHOULD handle
	// this as gracefully as possible, and MAY return this error code
	// to reject secondary calls.
	//
	// Recovery behavior: Caller SHOULD ensure that there are no other
	// calls pending for the specified volume, and then retry with
	// exponential back off.
	OPERATION_PENDING_FOR_VOLUME Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 2
	// Indicates that the specified `VolumeID` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeID` before
	// retrying.
	INVALID_VOLUME_ID Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 3
	// Indicates that the specified `VolumeMetadata` is not allowed or
	// understood by the Plugin. More human-readable information MAY
	// be provided in the `error_description` field.
	//
	// Recovery behavior: Caller MUST fix the `VolumeMetadata` before
	// retrying.
	INVALID_VOLUME_METADATA Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 4
	// Indicates that a volume corresponding to the specified
	// `VolumeID` does not exist.
	//
	// Recovery behavior: Caller SHOULD verify that the `VolumeID` is
	// correct and that the volume is accessible and has not been
	// deleted before retrying with exponential back off.
	VOLUME_DOES_NOT_EXIST Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 5
	// Indicates that a node corresponding to the specified `NodeID`
	// does not exist.
	//
	// Recovery behavior: Caller SHOULD verify that the `NodeID` is
	// correct and that the node is available and has not been
	// terminated or deleted before retrying.
	NODE_DOES_NOT_EXIST                   Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 6
	INVALID_NODE_ID                       Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 7
	VOLUME_NOT_ATTACHED_TO_SPECIFIED_NODE Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 8
	NODE_ID_REQUIRED                      Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode = 9
)

var Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "CALL_NOT_IMPLEMENTED",
	2: "OPERATION_PENDING_FOR_VOLUME",
	3: "INVALID_VOLUME_ID",
	4: "INVALID_VOLUME_METADATA",
	5: "VOLUME_DOES_NOT_EXIST",
	6: "NODE_DOES_NOT_EXIST",
	7: "INVALID_NODE_ID",
	8: "VOLUME_NOT_ATTACHED_TO_SPECIFIED_NODE",
	9: "NODE_ID_REQUIRED",
}
var Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                               0,
	"CALL_NOT_IMPLEMENTED":                  1,
	"OPERATION_PENDING_FOR_VOLUME":          2,
	"INVALID_VOLUME_ID":                     3,
	"INVALID_VOLUME_METADATA":               4,
	"VOLUME_DOES_NOT_EXIST":                 5,
	"NODE_DOES_NOT_EXIST":                   6,
	"INVALID_NODE_ID":                       7,
	"VOLUME_NOT_ATTACHED_TO_SPECIFIED_NODE": 8,
	"NODE_ID_REQUIRED":                      9,
}

func (Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 4, 0}
}

type Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `ValidateVolumeCapabilitiesErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN                  Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode = 0
	VOLUME_DOES_NOT_EXIST    Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode = 1
	UNSUPPORTED_MOUNT_OPTION Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode = 2
	UNSUPPORTED_VOLUME_TYPE  Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode = 3
	UNSUPPORTED_FS_TYPE      Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode = 4
)

var Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "VOLUME_DOES_NOT_EXIST",
	2: "UNSUPPORTED_MOUNT_OPTION",
	3: "UNSUPPORTED_VOLUME_TYPE",
	4: "UNSUPPORTED_FS_TYPE",
}
var Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode_value = map[string]int32{
	"UNKNOWN":                  0,
	"VOLUME_DOES_NOT_EXIST":    1,
	"UNSUPPORTED_MOUNT_OPTION": 2,
	"UNSUPPORTED_VOLUME_TYPE":  3,
	"UNSUPPORTED_FS_TYPE":      4,
}

func (Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 5, 0}
}

type Error_NodePublishVolumeError_NodePublishVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `NodePublishVolumeErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN                      Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 0
	OPERATION_PENDING_FOR_VOLUME Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 1
	VOLUME_DOES_NOT_EXIST        Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 2
	UNSUPPORTED_MOUNT_OPTION     Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 3
	UNSUPPORTED_VOLUME_TYPE      Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 4
	UNSUPPORTED_FS_TYPE          Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 5
	MOUNT_ERROR                  Error_NodePublishVolumeError_NodePublishVolumeErrorCode = 6
)

var Error_NodePublishVolumeError_NodePublishVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "OPERATION_PENDING_FOR_VOLUME",
	2: "VOLUME_DOES_NOT_EXIST",
	3: "UNSUPPORTED_MOUNT_OPTION",
	4: "UNSUPPORTED_VOLUME_TYPE",
	5: "UNSUPPORTED_FS_TYPE",
	6: "MOUNT_ERROR",
}
var Error_NodePublishVolumeError_NodePublishVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                      0,
	"OPERATION_PENDING_FOR_VOLUME": 1,
	"VOLUME_DOES_NOT_EXIST":        2,
	"UNSUPPORTED_MOUNT_OPTION":     3,
	"UNSUPPORTED_VOLUME_TYPE":      4,
	"UNSUPPORTED_FS_TYPE":          5,
	"MOUNT_ERROR":                  6,
}

func (Error_NodePublishVolumeError_NodePublishVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 6, 0}
}

type Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `NodeUnpublishVolumeErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN                      Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode = 0
	OPERATION_PENDING_FOR_VOLUME Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode = 1
	VOLUME_DOES_NOT_EXIST        Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode = 2
	UNMOUNT_ERROR                Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode = 3
)

var Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "OPERATION_PENDING_FOR_VOLUME",
	2: "VOLUME_DOES_NOT_EXIST",
	3: "UNMOUNT_ERROR",
}
var Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode_value = map[string]int32{
	"UNKNOWN":                      0,
	"OPERATION_PENDING_FOR_VOLUME": 1,
	"VOLUME_DOES_NOT_EXIST":        2,
	"UNMOUNT_ERROR":                3,
}

func (Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 7, 0}
}

type Error_ProbeNodeError_ProbeNodeErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `ProbeNodeErrorCode` code that an older CSI
	// client is not aware of, the client will see this code (the
	// default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN                          Error_ProbeNodeError_ProbeNodeErrorCode = 0
	BAD_PLUGIN_CONFIG                Error_ProbeNodeError_ProbeNodeErrorCode = 1
	MISSING_REQUIRED_HOST_DEPENDENCY Error_ProbeNodeError_ProbeNodeErrorCode = 2
)

var Error_ProbeNodeError_ProbeNodeErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "BAD_PLUGIN_CONFIG",
	2: "MISSING_REQUIRED_HOST_DEPENDENCY",
}
var Error_ProbeNodeError_ProbeNodeErrorCode_value = map[string]int32{
	"UNKNOWN":                          0,
	"BAD_PLUGIN_CONFIG":                1,
	"MISSING_REQUIRED_HOST_DEPENDENCY": 2,
}

func (Error_ProbeNodeError_ProbeNodeErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 8, 0}
}

type Error_GetNodeIDError_GetNodeIDErrorCode int32

const (
	// Default value for backwards compatibility. SHOULD NOT be
	// returned by Plugins. However, if a Plugin returns a
	// `GetNodeIDErrorCode` code that an older CSI client is not aware
	// of, the client will see this code (the default fallback).
	//
	// Recovery behavior: Caller SHOULD consider updating CSI client
	// to match Plugin CSI version.
	UNKNOWN                          Error_GetNodeIDError_GetNodeIDErrorCode = 0
	BAD_PLUGIN_CONFIG                Error_GetNodeIDError_GetNodeIDErrorCode = 1
	MISSING_REQUIRED_HOST_DEPENDENCY Error_GetNodeIDError_GetNodeIDErrorCode = 2
)

var Error_GetNodeIDError_GetNodeIDErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "BAD_PLUGIN_CONFIG",
	2: "MISSING_REQUIRED_HOST_DEPENDENCY",
}
var Error_GetNodeIDError_GetNodeIDErrorCode_value = map[string]int32{
	"UNKNOWN":                          0,
	"BAD_PLUGIN_CONFIG":                1,
	"MISSING_REQUIRED_HOST_DEPENDENCY": 2,
}

func (Error_GetNodeIDError_GetNodeIDErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 9, 0}
}

type GetSupportedVersionsRequest struct {
}

func (m *GetSupportedVersionsRequest) Reset()                    { *m = GetSupportedVersionsRequest{} }
func (*GetSupportedVersionsRequest) ProtoMessage()               {}
func (*GetSupportedVersionsRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{0} }

type GetSupportedVersionsResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*GetSupportedVersionsResponse_Result_
	//	*GetSupportedVersionsResponse_Error
	Reply isGetSupportedVersionsResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GetSupportedVersionsResponse) Reset()                    { *m = GetSupportedVersionsResponse{} }
func (*GetSupportedVersionsResponse) ProtoMessage()               {}
func (*GetSupportedVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{1} }

type isGetSupportedVersionsResponse_Reply interface {
	isGetSupportedVersionsResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSupportedVersionsResponse_Result_ struct {
	Result *GetSupportedVersionsResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GetSupportedVersionsResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GetSupportedVersionsResponse_Result_) isGetSupportedVersionsResponse_Reply() {}
func (*GetSupportedVersionsResponse_Error) isGetSupportedVersionsResponse_Reply()   {}

func (m *GetSupportedVersionsResponse) GetReply() isGetSupportedVersionsResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GetSupportedVersionsResponse) GetResult() *GetSupportedVersionsResponse_Result {
	if x, ok := m.GetReply().(*GetSupportedVersionsResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GetSupportedVersionsResponse) GetError() *Error {
	if x, ok := m.GetReply().(*GetSupportedVersionsResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetSupportedVersionsResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetSupportedVersionsResponse_OneofMarshaler, _GetSupportedVersionsResponse_OneofUnmarshaler, _GetSupportedVersionsResponse_OneofSizer, []interface{}{
		(*GetSupportedVersionsResponse_Result_)(nil),
		(*GetSupportedVersionsResponse_Error)(nil),
	}
}

func _GetSupportedVersionsResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetSupportedVersionsResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetSupportedVersionsResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GetSupportedVersionsResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetSupportedVersionsResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GetSupportedVersionsResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetSupportedVersionsResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetSupportedVersionsResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GetSupportedVersionsResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GetSupportedVersionsResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetSupportedVersionsResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetSupportedVersionsResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetSupportedVersionsResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetSupportedVersionsResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetSupportedVersionsResponse_Result struct {
	// All the versions that the Plugin supports. This field is
	// REQUIRED.
	SupportedVersions []*Version `protobuf:"bytes,1,rep,name=supported_versions,json=supportedVersions" json:"supported_versions,omitempty"`
}

func (m *GetSupportedVersionsResponse_Result) Reset()      { *m = GetSupportedVersionsResponse_Result{} }
func (*GetSupportedVersionsResponse_Result) ProtoMessage() {}
func (*GetSupportedVersionsResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{1, 0}
}

func (m *GetSupportedVersionsResponse_Result) GetSupportedVersions() []*Version {
	if m != nil {
		return m.SupportedVersions
	}
	return nil
}

// Specifies the version in Semantic Version 2.0 format.
type Version struct {
	Major uint32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor uint32 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	Patch uint32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{2} }

func (m *Version) GetMajor() uint32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *Version) GetMinor() uint32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *Version) GetPatch() uint32 {
	if m != nil {
		return m.Patch
	}
	return 0
}

type GetPluginInfoRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *GetPluginInfoRequest) Reset()                    { *m = GetPluginInfoRequest{} }
func (*GetPluginInfoRequest) ProtoMessage()               {}
func (*GetPluginInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{3} }

func (m *GetPluginInfoRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type GetPluginInfoResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*GetPluginInfoResponse_Result_
	//	*GetPluginInfoResponse_Error
	Reply isGetPluginInfoResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GetPluginInfoResponse) Reset()                    { *m = GetPluginInfoResponse{} }
func (*GetPluginInfoResponse) ProtoMessage()               {}
func (*GetPluginInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{4} }

type isGetPluginInfoResponse_Reply interface {
	isGetPluginInfoResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetPluginInfoResponse_Result_ struct {
	Result *GetPluginInfoResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GetPluginInfoResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GetPluginInfoResponse_Result_) isGetPluginInfoResponse_Reply() {}
func (*GetPluginInfoResponse_Error) isGetPluginInfoResponse_Reply()   {}

func (m *GetPluginInfoResponse) GetReply() isGetPluginInfoResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GetPluginInfoResponse) GetResult() *GetPluginInfoResponse_Result {
	if x, ok := m.GetReply().(*GetPluginInfoResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GetPluginInfoResponse) GetError() *Error {
	if x, ok := m.GetReply().(*GetPluginInfoResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetPluginInfoResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetPluginInfoResponse_OneofMarshaler, _GetPluginInfoResponse_OneofUnmarshaler, _GetPluginInfoResponse_OneofSizer, []interface{}{
		(*GetPluginInfoResponse_Result_)(nil),
		(*GetPluginInfoResponse_Error)(nil),
	}
}

func _GetPluginInfoResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetPluginInfoResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetPluginInfoResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GetPluginInfoResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetPluginInfoResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GetPluginInfoResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetPluginInfoResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetPluginInfoResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GetPluginInfoResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GetPluginInfoResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetPluginInfoResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetPluginInfoResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetPluginInfoResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetPluginInfoResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetPluginInfoResponse_Result struct {
	// This field is REQUIRED.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field is REQUIRED. Value of this field is opaque to the CO.
	VendorVersion string `protobuf:"bytes,2,opt,name=vendor_version,json=vendorVersion,proto3" json:"vendor_version,omitempty"`
	// This field is OPTIONAL. Values are opaque to the CO.
	Manifest map[string]string `protobuf:"bytes,3,rep,name=manifest" json:"manifest,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetPluginInfoResponse_Result) Reset()      { *m = GetPluginInfoResponse_Result{} }
func (*GetPluginInfoResponse_Result) ProtoMessage() {}
func (*GetPluginInfoResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{4, 0}
}

func (m *GetPluginInfoResponse_Result) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetPluginInfoResponse_Result) GetVendorVersion() string {
	if m != nil {
		return m.VendorVersion
	}
	return ""
}

func (m *GetPluginInfoResponse_Result) GetManifest() map[string]string {
	if m != nil {
		return m.Manifest
	}
	return nil
}

type CreateVolumeRequest struct {
	// The API version assumed by the CO. This field is REQUIRED.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The suggested name for the storage space. This field is REQUIRED.
	// It serves two purposes:
	// 1) Idempotency - This name is generated by the CO to achieve
	//    idempotency. If `CreateVolume` fails, the volume may or may not
	//    be provisioned. In this case, the CO may call `CreateVolume`
	//    again, with the same name, to ensure the volume exists. The
	//    Plugin should ensure that multiple `CreateVolume` calls for the
	//    same name do not result in more than one piece of storage
	//    provisioned corresponding to that name. If a Plugin is unable to
	//    enforce idempotency, the CO’s error recovery logic could result
	//    in multiple (unused) volumes being provisioned.
	// 2) Suggested name - Some storage systems allow callers to specify
	//    an identifier by which to refer to the newly provisioned
	//    storage. If a storage system supports this, it can optionally
	//    use this name as the identifier for the new volume.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// This field is OPTIONAL. This allows the CO to specify the capacity
	// requirement of the volume to be provisioned. If not specified, the
	// Plugin MAY choose an implementation-defined capacity range.
	CapacityRange *CapacityRange `protobuf:"bytes,3,opt,name=capacity_range,json=capacityRange" json:"capacity_range,omitempty"`
	// The capabilities that the provisioned volume MUST have: the Plugin
	// MUST provision a volume that could satisfy ANY ONE of the
	// capabilities specified in this list. The Plugin MUST assume that
	// the CO MAY use the  provisioned volume later with ANY of the
	// capabilities specified in this list. This also enables the CO to do
	// early validation: if ANY of the specified volume capabilities are
	// not supported by the Plugin, the call SHALL fail. This field is
	// REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,4,rep,name=volume_capabilities,json=volumeCapabilities" json:"volume_capabilities,omitempty"`
	// Plugin specific parameters passed in as opaque key-value pairs.
	// This field is OPTIONAL. The Plugin is responsible for parsing and
	// validating these parameters. COs will treat these as opaque.
	Parameters map[string]string `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateVolumeRequest) Reset()                    { *m = CreateVolumeRequest{} }
func (*CreateVolumeRequest) ProtoMessage()               {}
func (*CreateVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{5} }

func (m *CreateVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *CreateVolumeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeRequest) GetCapacityRange() *CapacityRange {
	if m != nil {
		return m.CapacityRange
	}
	return nil
}

func (m *CreateVolumeRequest) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

func (m *CreateVolumeRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type CreateVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*CreateVolumeResponse_Result_
	//	*CreateVolumeResponse_Error
	Reply isCreateVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *CreateVolumeResponse) Reset()                    { *m = CreateVolumeResponse{} }
func (*CreateVolumeResponse) ProtoMessage()               {}
func (*CreateVolumeResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{6} }

type isCreateVolumeResponse_Reply interface {
	isCreateVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateVolumeResponse_Result_ struct {
	Result *CreateVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type CreateVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*CreateVolumeResponse_Result_) isCreateVolumeResponse_Reply() {}
func (*CreateVolumeResponse_Error) isCreateVolumeResponse_Reply()   {}

func (m *CreateVolumeResponse) GetReply() isCreateVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *CreateVolumeResponse) GetResult() *CreateVolumeResponse_Result {
	if x, ok := m.GetReply().(*CreateVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *CreateVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*CreateVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateVolumeResponse_OneofMarshaler, _CreateVolumeResponse_OneofUnmarshaler, _CreateVolumeResponse_OneofSizer, []interface{}{
		(*CreateVolumeResponse_Result_)(nil),
		(*CreateVolumeResponse_Error)(nil),
	}
}

func _CreateVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *CreateVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *CreateVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _CreateVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &CreateVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &CreateVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *CreateVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CreateVolumeResponse_Result struct {
	// Contains all attributes of the newly created volume that are
	// relevant to the CO along with information required by the Plugin
	// to uniquely identifying the volume. This field is REQUIRED.
	VolumeInfo *VolumeInfo `protobuf:"bytes,1,opt,name=volume_info,json=volumeInfo" json:"volume_info,omitempty"`
}

func (m *CreateVolumeResponse_Result) Reset()      { *m = CreateVolumeResponse_Result{} }
func (*CreateVolumeResponse_Result) ProtoMessage() {}
func (*CreateVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{6, 0}
}

func (m *CreateVolumeResponse_Result) GetVolumeInfo() *VolumeInfo {
	if m != nil {
		return m.VolumeInfo
	}
	return nil
}

// Specify a capability of a volume.
type VolumeCapability struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Value:
	//	*VolumeCapability_Block
	//	*VolumeCapability_Mount
	Value isVolumeCapability_Value `protobuf_oneof:"value"`
}

func (m *VolumeCapability) Reset()                    { *m = VolumeCapability{} }
func (*VolumeCapability) ProtoMessage()               {}
func (*VolumeCapability) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{7} }

type isVolumeCapability_Value interface {
	isVolumeCapability_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VolumeCapability_Block struct {
	Block *VolumeCapability_BlockVolume `protobuf:"bytes,1,opt,name=block,oneof"`
}
type VolumeCapability_Mount struct {
	Mount *VolumeCapability_MountVolume `protobuf:"bytes,2,opt,name=mount,oneof"`
}

func (*VolumeCapability_Block) isVolumeCapability_Value() {}
func (*VolumeCapability_Mount) isVolumeCapability_Value() {}

func (m *VolumeCapability) GetValue() isVolumeCapability_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *VolumeCapability) GetBlock() *VolumeCapability_BlockVolume {
	if x, ok := m.GetValue().(*VolumeCapability_Block); ok {
		return x.Block
	}
	return nil
}

func (m *VolumeCapability) GetMount() *VolumeCapability_MountVolume {
	if x, ok := m.GetValue().(*VolumeCapability_Mount); ok {
		return x.Mount
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VolumeCapability) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VolumeCapability_OneofMarshaler, _VolumeCapability_OneofUnmarshaler, _VolumeCapability_OneofSizer, []interface{}{
		(*VolumeCapability_Block)(nil),
		(*VolumeCapability_Mount)(nil),
	}
}

func _VolumeCapability_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VolumeCapability)
	// value
	switch x := m.Value.(type) {
	case *VolumeCapability_Block:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case *VolumeCapability_Mount:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mount); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VolumeCapability.Value has unexpected type %T", x)
	}
	return nil
}

func _VolumeCapability_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VolumeCapability)
	switch tag {
	case 1: // value.block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VolumeCapability_BlockVolume)
		err := b.DecodeMessage(msg)
		m.Value = &VolumeCapability_Block{msg}
		return true, err
	case 2: // value.mount
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VolumeCapability_MountVolume)
		err := b.DecodeMessage(msg)
		m.Value = &VolumeCapability_Mount{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VolumeCapability_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VolumeCapability)
	// value
	switch x := m.Value.(type) {
	case *VolumeCapability_Block:
		s := proto.Size(x.Block)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VolumeCapability_Mount:
		s := proto.Size(x.Mount)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type VolumeCapability_BlockVolume struct {
}

func (m *VolumeCapability_BlockVolume) Reset()      { *m = VolumeCapability_BlockVolume{} }
func (*VolumeCapability_BlockVolume) ProtoMessage() {}
func (*VolumeCapability_BlockVolume) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{7, 0}
}

type VolumeCapability_MountVolume struct {
	// The filesystem type. This field is OPTIONAL.
	FsType string `protobuf:"bytes,1,opt,name=fs_type,json=fsType,proto3" json:"fs_type,omitempty"`
	// The mount options that can be used for the volume. This field is
	// OPTIONAL. `mount_flags` MAY contain sensitive information.
	// Therefore, the CO and the Plugin MUST NOT leak this information
	// to untrusted entities.
	MountFlags []string `protobuf:"bytes,2,rep,name=mount_flags,json=mountFlags" json:"mount_flags,omitempty"`
}

func (m *VolumeCapability_MountVolume) Reset()      { *m = VolumeCapability_MountVolume{} }
func (*VolumeCapability_MountVolume) ProtoMessage() {}
func (*VolumeCapability_MountVolume) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{7, 1}
}

func (m *VolumeCapability_MountVolume) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *VolumeCapability_MountVolume) GetMountFlags() []string {
	if m != nil {
		return m.MountFlags
	}
	return nil
}

// The capacity of the storage space in bytes. To specify an exact size,
// `required_bytes` and `limit_bytes` can be set to the same value. At
// least one of the these fields MUST be specified.
type CapacityRange struct {
	// Volume must be at least this big.
	RequiredBytes uint64 `protobuf:"varint,1,opt,name=required_bytes,json=requiredBytes,proto3" json:"required_bytes,omitempty"`
	// Volume must not be bigger than this.
	LimitBytes uint64 `protobuf:"varint,2,opt,name=limit_bytes,json=limitBytes,proto3" json:"limit_bytes,omitempty"`
}

func (m *CapacityRange) Reset()                    { *m = CapacityRange{} }
func (*CapacityRange) ProtoMessage()               {}
func (*CapacityRange) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{8} }

func (m *CapacityRange) GetRequiredBytes() uint64 {
	if m != nil {
		return m.RequiredBytes
	}
	return 0
}

func (m *CapacityRange) GetLimitBytes() uint64 {
	if m != nil {
		return m.LimitBytes
	}
	return 0
}

// The information about a provisioned volume.
type VolumeInfo struct {
	// The capacity of the volume in bytes. This field is OPTIONAL. If not
	// set, it indicates that the capacity of the volume is unknown (e.g.,
	// NFS share). If set, it MUST be non-zero.
	CapacityBytes uint64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// Contains information about how the volume can be accessed. This
	// field is REQUIRED.
	AccessMode *AccessMode `protobuf:"bytes,2,opt,name=access_mode,json=accessMode" json:"access_mode,omitempty"`
	// Contains identity information for the created volume. This field is
	// REQUIRED. The identity information will be used by the CO in
	// subsequent calls to refer to the provisioned volume.
	Id *VolumeID `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Metadata of the created volume. This field is OPTIONAL. If set, the
	// CO SHALL pass this information along with the `id` to subsequent
	// calls.
	Metadata *VolumeMetadata `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *VolumeInfo) Reset()                    { *m = VolumeInfo{} }
func (*VolumeInfo) ProtoMessage()               {}
func (*VolumeInfo) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{9} }

func (m *VolumeInfo) GetCapacityBytes() uint64 {
	if m != nil {
		return m.CapacityBytes
	}
	return 0
}

func (m *VolumeInfo) GetAccessMode() *AccessMode {
	if m != nil {
		return m.AccessMode
	}
	return nil
}

func (m *VolumeInfo) GetId() *VolumeID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *VolumeInfo) GetMetadata() *VolumeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Specify how a volume can be accessed.
type AccessMode struct {
	// This field is REQUIRED.
	Mode AccessMode_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=AccessMode_Mode" json:"mode,omitempty"`
}

func (m *AccessMode) Reset()                    { *m = AccessMode{} }
func (*AccessMode) ProtoMessage()               {}
func (*AccessMode) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{10} }

func (m *AccessMode) GetMode() AccessMode_Mode {
	if m != nil {
		return m.Mode
	}
	return UNKNOWN
}

// The identity of the volume.
type VolumeID struct {
	// The identity of the provisioned volume specified by the Plugin in
	// the form of key-value pairs. This field is REQUIRED. Given this
	// information will be passed around by the CO, it is RECOMMENDED that
	// each Plugin keeps this information as small as possible.
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VolumeID) Reset()                    { *m = VolumeID{} }
func (*VolumeID) ProtoMessage()               {}
func (*VolumeID) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{11} }

func (m *VolumeID) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

// The metadata information about the volume.
type VolumeMetadata struct {
	// The metadata information about the provisioned volume specified by
	// the Plugin in the form of key-value pairs. This field is OPTIONAL.
	// This field MAY contain sensitive information. Therefore, the CO
	// MUST NOT leak this information to untrusted entities. Given this
	// information will be passed around by the CO, it is RECOMMENDED that
	// each Plugin keeps this information as small as possible.
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VolumeMetadata) Reset()                    { *m = VolumeMetadata{} }
func (*VolumeMetadata) ProtoMessage()               {}
func (*VolumeMetadata) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{12} }

func (m *VolumeMetadata) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type DeleteVolumeRequest struct {
	// The API version assumed by the CO. This field is REQUIRED.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The ID of the volume to be deprovisioned. This field is REQUIRED.
	VolumeId *VolumeID `protobuf:"bytes,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The metadata of the volume to be deprovisioned. This field is
	// OPTIONAL.
	VolumeMetadata *VolumeMetadata `protobuf:"bytes,3,opt,name=volume_metadata,json=volumeMetadata" json:"volume_metadata,omitempty"`
}

func (m *DeleteVolumeRequest) Reset()                    { *m = DeleteVolumeRequest{} }
func (*DeleteVolumeRequest) ProtoMessage()               {}
func (*DeleteVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{13} }

func (m *DeleteVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *DeleteVolumeRequest) GetVolumeId() *VolumeID {
	if m != nil {
		return m.VolumeId
	}
	return nil
}

func (m *DeleteVolumeRequest) GetVolumeMetadata() *VolumeMetadata {
	if m != nil {
		return m.VolumeMetadata
	}
	return nil
}

type DeleteVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*DeleteVolumeResponse_Result_
	//	*DeleteVolumeResponse_Error
	Reply isDeleteVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *DeleteVolumeResponse) Reset()                    { *m = DeleteVolumeResponse{} }
func (*DeleteVolumeResponse) ProtoMessage()               {}
func (*DeleteVolumeResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{14} }

type isDeleteVolumeResponse_Reply interface {
	isDeleteVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeleteVolumeResponse_Result_ struct {
	Result *DeleteVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type DeleteVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*DeleteVolumeResponse_Result_) isDeleteVolumeResponse_Reply() {}
func (*DeleteVolumeResponse_Error) isDeleteVolumeResponse_Reply()   {}

func (m *DeleteVolumeResponse) GetReply() isDeleteVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *DeleteVolumeResponse) GetResult() *DeleteVolumeResponse_Result {
	if x, ok := m.GetReply().(*DeleteVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *DeleteVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*DeleteVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeleteVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeleteVolumeResponse_OneofMarshaler, _DeleteVolumeResponse_OneofUnmarshaler, _DeleteVolumeResponse_OneofSizer, []interface{}{
		(*DeleteVolumeResponse_Result_)(nil),
		(*DeleteVolumeResponse_Error)(nil),
	}
}

func _DeleteVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeleteVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *DeleteVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *DeleteVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeleteVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _DeleteVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeleteVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &DeleteVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &DeleteVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeleteVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeleteVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *DeleteVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DeleteVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DeleteVolumeResponse_Result struct {
}

func (m *DeleteVolumeResponse_Result) Reset()      { *m = DeleteVolumeResponse_Result{} }
func (*DeleteVolumeResponse_Result) ProtoMessage() {}
func (*DeleteVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{14, 0}
}

type ControllerPublishVolumeRequest struct {
	// The API version assumed by the CO. This field is REQUIRED.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The ID of the volume to be used on a node. This field is REQUIRED.
	VolumeId *VolumeID `protobuf:"bytes,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The metadata of the volume to be used on a node. This field is
	// OPTIONAL.
	VolumeMetadata *VolumeMetadata `protobuf:"bytes,3,opt,name=volume_metadata,json=volumeMetadata" json:"volume_metadata,omitempty"`
	// The ID of the node. This field is OPTIONAL. The CO SHALL set (or
	// clear) this field to match the `NodeID` returned by `GetNodeID`.
	// `GetNodeID` is allowed to omit `NodeID` from a successful `Result`;
	// in such cases the CO SHALL NOT specify this field.
	NodeId *NodeID `protobuf:"bytes,4,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Whether to publish the volume in readonly mode. This field is
	// REQUIRED.
	Readonly bool `protobuf:"varint,5,opt,name=readonly,proto3" json:"readonly,omitempty"`
}

func (m *ControllerPublishVolumeRequest) Reset()      { *m = ControllerPublishVolumeRequest{} }
func (*ControllerPublishVolumeRequest) ProtoMessage() {}
func (*ControllerPublishVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{15}
}

func (m *ControllerPublishVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetVolumeId() *VolumeID {
	if m != nil {
		return m.VolumeId
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetVolumeMetadata() *VolumeMetadata {
	if m != nil {
		return m.VolumeMetadata
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetNodeId() *NodeID {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type ControllerPublishVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ControllerPublishVolumeResponse_Result_
	//	*ControllerPublishVolumeResponse_Error
	Reply isControllerPublishVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ControllerPublishVolumeResponse) Reset()      { *m = ControllerPublishVolumeResponse{} }
func (*ControllerPublishVolumeResponse) ProtoMessage() {}
func (*ControllerPublishVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{16}
}

type isControllerPublishVolumeResponse_Reply interface {
	isControllerPublishVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControllerPublishVolumeResponse_Result_ struct {
	Result *ControllerPublishVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ControllerPublishVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ControllerPublishVolumeResponse_Result_) isControllerPublishVolumeResponse_Reply() {}
func (*ControllerPublishVolumeResponse_Error) isControllerPublishVolumeResponse_Reply()   {}

func (m *ControllerPublishVolumeResponse) GetReply() isControllerPublishVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ControllerPublishVolumeResponse) GetResult() *ControllerPublishVolumeResponse_Result {
	if x, ok := m.GetReply().(*ControllerPublishVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ControllerPublishVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ControllerPublishVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ControllerPublishVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ControllerPublishVolumeResponse_OneofMarshaler, _ControllerPublishVolumeResponse_OneofUnmarshaler, _ControllerPublishVolumeResponse_OneofSizer, []interface{}{
		(*ControllerPublishVolumeResponse_Result_)(nil),
		(*ControllerPublishVolumeResponse_Error)(nil),
	}
}

func _ControllerPublishVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ControllerPublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerPublishVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ControllerPublishVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ControllerPublishVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ControllerPublishVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ControllerPublishVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControllerPublishVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerPublishVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerPublishVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ControllerPublishVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ControllerPublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerPublishVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControllerPublishVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ControllerPublishVolumeResponse_Result struct {
	// The SP specific information that will be passed to the Plugin in
	// the subsequent `NodePublishVolume` call for the given volume.
	// This information is opaque to the CO. This field is OPTIONAL.
	PublishVolumeInfo *PublishVolumeInfo `protobuf:"bytes,1,opt,name=publish_volume_info,json=publishVolumeInfo" json:"publish_volume_info,omitempty"`
}

func (m *ControllerPublishVolumeResponse_Result) Reset() {
	*m = ControllerPublishVolumeResponse_Result{}
}
func (*ControllerPublishVolumeResponse_Result) ProtoMessage() {}
func (*ControllerPublishVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{16, 0}
}

func (m *ControllerPublishVolumeResponse_Result) GetPublishVolumeInfo() *PublishVolumeInfo {
	if m != nil {
		return m.PublishVolumeInfo
	}
	return nil
}

type NodeID struct {
	// Information about a node in the form of key-value pairs. This
	// information is opaque to the CO. Given this information will be
	// passed around by the CO, it is RECOMMENDED that each Plugin keeps
	// this information as small as possible.
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NodeID) Reset()                    { *m = NodeID{} }
func (*NodeID) ProtoMessage()               {}
func (*NodeID) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{17} }

func (m *NodeID) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type PublishVolumeInfo struct {
	// Information returned by the Plugin in `ControllerPublishVolume`
	// call. It is in the form of key-value pairs, and is opaque to the
	// CO. Given this information will be passed around by the CO, it is
	// RECOMMENDED that each Plugin keeps this information as small as
	// possible.
	Values map[string]string `protobuf:"bytes,1,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PublishVolumeInfo) Reset()                    { *m = PublishVolumeInfo{} }
func (*PublishVolumeInfo) ProtoMessage()               {}
func (*PublishVolumeInfo) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{18} }

func (m *PublishVolumeInfo) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

type ControllerUnpublishVolumeRequest struct {
	// The API version assumed by the CO. This field is REQUIRED.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId *VolumeID `protobuf:"bytes,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The metadata of the volume. This field is OPTIONAL.
	VolumeMetadata *VolumeMetadata `protobuf:"bytes,3,opt,name=volume_metadata,json=volumeMetadata" json:"volume_metadata,omitempty"`
	// The ID of the node. This field is OPTIONAL. The CO SHALL set (or
	// clear) this field to match the `NodeID` returned by `GetNodeID`.
	// `GetNodeID` is allowed to omit `NodeID` from a successful `Result`;
	// in such cases the CO SHALL NOT specify this field.
	//
	// If `GetNodeID` does not omit `NodeID` from a successful `Result`,
	// the CO MAY omit this field as well, indicating that it does not
	// know which node the volume was previously used. The Plugin SHOULD
	// return an Error if this is not supported.
	NodeId *NodeID `protobuf:"bytes,4,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
}

func (m *ControllerUnpublishVolumeRequest) Reset()      { *m = ControllerUnpublishVolumeRequest{} }
func (*ControllerUnpublishVolumeRequest) ProtoMessage() {}
func (*ControllerUnpublishVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{19}
}

func (m *ControllerUnpublishVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ControllerUnpublishVolumeRequest) GetVolumeId() *VolumeID {
	if m != nil {
		return m.VolumeId
	}
	return nil
}

func (m *ControllerUnpublishVolumeRequest) GetVolumeMetadata() *VolumeMetadata {
	if m != nil {
		return m.VolumeMetadata
	}
	return nil
}

func (m *ControllerUnpublishVolumeRequest) GetNodeId() *NodeID {
	if m != nil {
		return m.NodeId
	}
	return nil
}

type ControllerUnpublishVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ControllerUnpublishVolumeResponse_Result_
	//	*ControllerUnpublishVolumeResponse_Error
	Reply isControllerUnpublishVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ControllerUnpublishVolumeResponse) Reset()      { *m = ControllerUnpublishVolumeResponse{} }
func (*ControllerUnpublishVolumeResponse) ProtoMessage() {}
func (*ControllerUnpublishVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{20}
}

type isControllerUnpublishVolumeResponse_Reply interface {
	isControllerUnpublishVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControllerUnpublishVolumeResponse_Result_ struct {
	Result *ControllerUnpublishVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ControllerUnpublishVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ControllerUnpublishVolumeResponse_Result_) isControllerUnpublishVolumeResponse_Reply() {}
func (*ControllerUnpublishVolumeResponse_Error) isControllerUnpublishVolumeResponse_Reply()   {}

func (m *ControllerUnpublishVolumeResponse) GetReply() isControllerUnpublishVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ControllerUnpublishVolumeResponse) GetResult() *ControllerUnpublishVolumeResponse_Result {
	if x, ok := m.GetReply().(*ControllerUnpublishVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ControllerUnpublishVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ControllerUnpublishVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ControllerUnpublishVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ControllerUnpublishVolumeResponse_OneofMarshaler, _ControllerUnpublishVolumeResponse_OneofUnmarshaler, _ControllerUnpublishVolumeResponse_OneofSizer, []interface{}{
		(*ControllerUnpublishVolumeResponse_Result_)(nil),
		(*ControllerUnpublishVolumeResponse_Error)(nil),
	}
}

func _ControllerUnpublishVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ControllerUnpublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerUnpublishVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ControllerUnpublishVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ControllerUnpublishVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ControllerUnpublishVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ControllerUnpublishVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControllerUnpublishVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerUnpublishVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerUnpublishVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ControllerUnpublishVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ControllerUnpublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerUnpublishVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControllerUnpublishVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ControllerUnpublishVolumeResponse_Result struct {
}

func (m *ControllerUnpublishVolumeResponse_Result) Reset() {
	*m = ControllerUnpublishVolumeResponse_Result{}
}
func (*ControllerUnpublishVolumeResponse_Result) ProtoMessage() {}
func (*ControllerUnpublishVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{20, 0}
}

type ValidateVolumeCapabilitiesRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The information about the volume to check. This is a REQUIRED
	// field.
	VolumeInfo *VolumeInfo `protobuf:"bytes,2,opt,name=volume_info,json=volumeInfo" json:"volume_info,omitempty"`
	// The capabilities that the CO wants to check for the volume. This
	// call SHALL return “supported” only if all the volume capabilities
	// specified below are supported.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,3,rep,name=volume_capabilities,json=volumeCapabilities" json:"volume_capabilities,omitempty"`
}

func (m *ValidateVolumeCapabilitiesRequest) Reset()      { *m = ValidateVolumeCapabilitiesRequest{} }
func (*ValidateVolumeCapabilitiesRequest) ProtoMessage() {}
func (*ValidateVolumeCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{21}
}

func (m *ValidateVolumeCapabilitiesRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesRequest) GetVolumeInfo() *VolumeInfo {
	if m != nil {
		return m.VolumeInfo
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesRequest) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

type ValidateVolumeCapabilitiesResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ValidateVolumeCapabilitiesResponse_Result_
	//	*ValidateVolumeCapabilitiesResponse_Error
	Reply isValidateVolumeCapabilitiesResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ValidateVolumeCapabilitiesResponse) Reset()      { *m = ValidateVolumeCapabilitiesResponse{} }
func (*ValidateVolumeCapabilitiesResponse) ProtoMessage() {}
func (*ValidateVolumeCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{22}
}

type isValidateVolumeCapabilitiesResponse_Reply interface {
	isValidateVolumeCapabilitiesResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ValidateVolumeCapabilitiesResponse_Result_ struct {
	Result *ValidateVolumeCapabilitiesResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ValidateVolumeCapabilitiesResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ValidateVolumeCapabilitiesResponse_Result_) isValidateVolumeCapabilitiesResponse_Reply() {}
func (*ValidateVolumeCapabilitiesResponse_Error) isValidateVolumeCapabilitiesResponse_Reply()   {}

func (m *ValidateVolumeCapabilitiesResponse) GetReply() isValidateVolumeCapabilitiesResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesResponse) GetResult() *ValidateVolumeCapabilitiesResponse_Result {
	if x, ok := m.GetReply().(*ValidateVolumeCapabilitiesResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ValidateVolumeCapabilitiesResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ValidateVolumeCapabilitiesResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ValidateVolumeCapabilitiesResponse_OneofMarshaler, _ValidateVolumeCapabilitiesResponse_OneofUnmarshaler, _ValidateVolumeCapabilitiesResponse_OneofSizer, []interface{}{
		(*ValidateVolumeCapabilitiesResponse_Result_)(nil),
		(*ValidateVolumeCapabilitiesResponse_Error)(nil),
	}
}

func _ValidateVolumeCapabilitiesResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ValidateVolumeCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ValidateVolumeCapabilitiesResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ValidateVolumeCapabilitiesResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ValidateVolumeCapabilitiesResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ValidateVolumeCapabilitiesResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ValidateVolumeCapabilitiesResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ValidateVolumeCapabilitiesResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ValidateVolumeCapabilitiesResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ValidateVolumeCapabilitiesResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ValidateVolumeCapabilitiesResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ValidateVolumeCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ValidateVolumeCapabilitiesResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ValidateVolumeCapabilitiesResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValidateVolumeCapabilitiesResponse_Result struct {
	// True if the Plugin supports the specified capabilities for the
	// given volume. This field is REQUIRED.
	Supported bool `protobuf:"varint,1,opt,name=supported,proto3" json:"supported,omitempty"`
	// Message to the CO if `supported` above is false. This field is
	// OPTIONAL.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ValidateVolumeCapabilitiesResponse_Result) Reset() {
	*m = ValidateVolumeCapabilitiesResponse_Result{}
}
func (*ValidateVolumeCapabilitiesResponse_Result) ProtoMessage() {}
func (*ValidateVolumeCapabilitiesResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{22, 0}
}

func (m *ValidateVolumeCapabilitiesResponse_Result) GetSupported() bool {
	if m != nil {
		return m.Supported
	}
	return false
}

func (m *ValidateVolumeCapabilitiesResponse_Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ListVolumesRequest struct {
	// The API version assumed by the CO. This field is REQUIRED.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// If specified, the Plugin MUST NOT return more entries than this
	// number in the response. If the actual number of entries is more
	// than this number, the Plugin MUST set `next_token` in the response
	// which can be used to get the next page of entries in the subsequent
	// `ListVolumes` call. This field is OPTIONAL. If not specified, it
	// means there is no restriction on the number of entries that can be
	// returned.
	MaxEntries uint32 `protobuf:"varint,2,opt,name=max_entries,json=maxEntries,proto3" json:"max_entries,omitempty"`
	// A token to specify where to start paginating. Set this field to
	// `next_token` returned by a previous `ListVolumes` call to get the
	// next page of entries.
	StartingToken string `protobuf:"bytes,3,opt,name=starting_token,json=startingToken,proto3" json:"starting_token,omitempty"`
}

func (m *ListVolumesRequest) Reset()                    { *m = ListVolumesRequest{} }
func (*ListVolumesRequest) ProtoMessage()               {}
func (*ListVolumesRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{23} }

func (m *ListVolumesRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ListVolumesRequest) GetMaxEntries() uint32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *ListVolumesRequest) GetStartingToken() string {
	if m != nil {
		return m.StartingToken
	}
	return ""
}

type ListVolumesResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ListVolumesResponse_Result_
	//	*ListVolumesResponse_Error
	Reply isListVolumesResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ListVolumesResponse) Reset()                    { *m = ListVolumesResponse{} }
func (*ListVolumesResponse) ProtoMessage()               {}
func (*ListVolumesResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{24} }

type isListVolumesResponse_Reply interface {
	isListVolumesResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListVolumesResponse_Result_ struct {
	Result *ListVolumesResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ListVolumesResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ListVolumesResponse_Result_) isListVolumesResponse_Reply() {}
func (*ListVolumesResponse_Error) isListVolumesResponse_Reply()   {}

func (m *ListVolumesResponse) GetReply() isListVolumesResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ListVolumesResponse) GetResult() *ListVolumesResponse_Result {
	if x, ok := m.GetReply().(*ListVolumesResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ListVolumesResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ListVolumesResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListVolumesResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListVolumesResponse_OneofMarshaler, _ListVolumesResponse_OneofUnmarshaler, _ListVolumesResponse_OneofSizer, []interface{}{
		(*ListVolumesResponse_Result_)(nil),
		(*ListVolumesResponse_Error)(nil),
	}
}

func _ListVolumesResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListVolumesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ListVolumesResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ListVolumesResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ListVolumesResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ListVolumesResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListVolumesResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListVolumesResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ListVolumesResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ListVolumesResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ListVolumesResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListVolumesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ListVolumesResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListVolumesResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListVolumesResponse_Result struct {
	Entries []*ListVolumesResponse_Result_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	// This token allows you to get the next page of entries for
	// `ListVolumes` request. If the number of entries is larger than
	// `max_entries`, use the `next_token` as a value for the
	// `starting_token` field in the next `ListVolumes` request. This
	// field is OPTIONAL.
	NextToken string `protobuf:"bytes,2,opt,name=next_token,json=nextToken,proto3" json:"next_token,omitempty"`
}

func (m *ListVolumesResponse_Result) Reset()      { *m = ListVolumesResponse_Result{} }
func (*ListVolumesResponse_Result) ProtoMessage() {}
func (*ListVolumesResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{24, 0}
}

func (m *ListVolumesResponse_Result) GetEntries() []*ListVolumesResponse_Result_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *ListVolumesResponse_Result) GetNextToken() string {
	if m != nil {
		return m.NextToken
	}
	return ""
}

type ListVolumesResponse_Result_Entry struct {
	VolumeInfo *VolumeInfo `protobuf:"bytes,1,opt,name=volume_info,json=volumeInfo" json:"volume_info,omitempty"`
}

func (m *ListVolumesResponse_Result_Entry) Reset()      { *m = ListVolumesResponse_Result_Entry{} }
func (*ListVolumesResponse_Result_Entry) ProtoMessage() {}
func (*ListVolumesResponse_Result_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{24, 0, 0}
}

func (m *ListVolumesResponse_Result_Entry) GetVolumeInfo() *VolumeInfo {
	if m != nil {
		return m.VolumeInfo
	}
	return nil
}

type GetCapacityRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *GetCapacityRequest) Reset()                    { *m = GetCapacityRequest{} }
func (*GetCapacityRequest) ProtoMessage()               {}
func (*GetCapacityRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{25} }

func (m *GetCapacityRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type GetCapacityResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*GetCapacityResponse_Result_
	//	*GetCapacityResponse_Error
	Reply isGetCapacityResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GetCapacityResponse) Reset()                    { *m = GetCapacityResponse{} }
func (*GetCapacityResponse) ProtoMessage()               {}
func (*GetCapacityResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{26} }

type isGetCapacityResponse_Reply interface {
	isGetCapacityResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetCapacityResponse_Result_ struct {
	Result *GetCapacityResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GetCapacityResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GetCapacityResponse_Result_) isGetCapacityResponse_Reply() {}
func (*GetCapacityResponse_Error) isGetCapacityResponse_Reply()   {}

func (m *GetCapacityResponse) GetReply() isGetCapacityResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GetCapacityResponse) GetResult() *GetCapacityResponse_Result {
	if x, ok := m.GetReply().(*GetCapacityResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GetCapacityResponse) GetError() *Error {
	if x, ok := m.GetReply().(*GetCapacityResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetCapacityResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetCapacityResponse_OneofMarshaler, _GetCapacityResponse_OneofUnmarshaler, _GetCapacityResponse_OneofSizer, []interface{}{
		(*GetCapacityResponse_Result_)(nil),
		(*GetCapacityResponse_Error)(nil),
	}
}

func _GetCapacityResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetCapacityResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetCapacityResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GetCapacityResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetCapacityResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GetCapacityResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetCapacityResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetCapacityResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GetCapacityResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GetCapacityResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetCapacityResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetCapacityResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetCapacityResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetCapacityResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetCapacityResponse_Result struct {
	// The total capacity (available + used) of the storage pool from
	// which the controller provisions volumes. This is a REQUIRED
	// field.
	TotalCapacity uint64 `protobuf:"varint,1,opt,name=total_capacity,json=totalCapacity,proto3" json:"total_capacity,omitempty"`
}

func (m *GetCapacityResponse_Result) Reset()      { *m = GetCapacityResponse_Result{} }
func (*GetCapacityResponse_Result) ProtoMessage() {}
func (*GetCapacityResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{26, 0}
}

func (m *GetCapacityResponse_Result) GetTotalCapacity() uint64 {
	if m != nil {
		return m.TotalCapacity
	}
	return 0
}

type ControllerGetCapabilitiesRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *ControllerGetCapabilitiesRequest) Reset()      { *m = ControllerGetCapabilitiesRequest{} }
func (*ControllerGetCapabilitiesRequest) ProtoMessage() {}
func (*ControllerGetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{27}
}

func (m *ControllerGetCapabilitiesRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type ControllerGetCapabilitiesResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ControllerGetCapabilitiesResponse_Result_
	//	*ControllerGetCapabilitiesResponse_Error
	Reply isControllerGetCapabilitiesResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ControllerGetCapabilitiesResponse) Reset()      { *m = ControllerGetCapabilitiesResponse{} }
func (*ControllerGetCapabilitiesResponse) ProtoMessage() {}
func (*ControllerGetCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{28}
}

type isControllerGetCapabilitiesResponse_Reply interface {
	isControllerGetCapabilitiesResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControllerGetCapabilitiesResponse_Result_ struct {
	Result *ControllerGetCapabilitiesResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ControllerGetCapabilitiesResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ControllerGetCapabilitiesResponse_Result_) isControllerGetCapabilitiesResponse_Reply() {}
func (*ControllerGetCapabilitiesResponse_Error) isControllerGetCapabilitiesResponse_Reply()   {}

func (m *ControllerGetCapabilitiesResponse) GetReply() isControllerGetCapabilitiesResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ControllerGetCapabilitiesResponse) GetResult() *ControllerGetCapabilitiesResponse_Result {
	if x, ok := m.GetReply().(*ControllerGetCapabilitiesResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ControllerGetCapabilitiesResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ControllerGetCapabilitiesResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ControllerGetCapabilitiesResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ControllerGetCapabilitiesResponse_OneofMarshaler, _ControllerGetCapabilitiesResponse_OneofUnmarshaler, _ControllerGetCapabilitiesResponse_OneofSizer, []interface{}{
		(*ControllerGetCapabilitiesResponse_Result_)(nil),
		(*ControllerGetCapabilitiesResponse_Error)(nil),
	}
}

func _ControllerGetCapabilitiesResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ControllerGetCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerGetCapabilitiesResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ControllerGetCapabilitiesResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ControllerGetCapabilitiesResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ControllerGetCapabilitiesResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ControllerGetCapabilitiesResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControllerGetCapabilitiesResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerGetCapabilitiesResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ControllerGetCapabilitiesResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ControllerGetCapabilitiesResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ControllerGetCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ControllerGetCapabilitiesResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControllerGetCapabilitiesResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ControllerGetCapabilitiesResponse_Result struct {
	// All the capabilities that the controller service supports. This
	// field is OPTIONAL.
	Capabilities []*ControllerServiceCapability `protobuf:"bytes,2,rep,name=capabilities" json:"capabilities,omitempty"`
}

func (m *ControllerGetCapabilitiesResponse_Result) Reset() {
	*m = ControllerGetCapabilitiesResponse_Result{}
}
func (*ControllerGetCapabilitiesResponse_Result) ProtoMessage() {}
func (*ControllerGetCapabilitiesResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{28, 0}
}

func (m *ControllerGetCapabilitiesResponse_Result) GetCapabilities() []*ControllerServiceCapability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Specifies a capability of the controller service.
type ControllerServiceCapability struct {
	// Types that are valid to be assigned to Type:
	//	*ControllerServiceCapability_Rpc
	//	*ControllerServiceCapability_VolumeCapability
	Type isControllerServiceCapability_Type `protobuf_oneof:"type"`
}

func (m *ControllerServiceCapability) Reset()                    { *m = ControllerServiceCapability{} }
func (*ControllerServiceCapability) ProtoMessage()               {}
func (*ControllerServiceCapability) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{29} }

type isControllerServiceCapability_Type interface {
	isControllerServiceCapability_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControllerServiceCapability_Rpc struct {
	Rpc *ControllerServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,oneof"`
}
type ControllerServiceCapability_VolumeCapability struct {
	VolumeCapability *VolumeCapability `protobuf:"bytes,2,opt,name=volume_capability,json=volumeCapability,oneof"`
}

func (*ControllerServiceCapability_Rpc) isControllerServiceCapability_Type()              {}
func (*ControllerServiceCapability_VolumeCapability) isControllerServiceCapability_Type() {}

func (m *ControllerServiceCapability) GetType() isControllerServiceCapability_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ControllerServiceCapability) GetRpc() *ControllerServiceCapability_RPC {
	if x, ok := m.GetType().(*ControllerServiceCapability_Rpc); ok {
		return x.Rpc
	}
	return nil
}

func (m *ControllerServiceCapability) GetVolumeCapability() *VolumeCapability {
	if x, ok := m.GetType().(*ControllerServiceCapability_VolumeCapability); ok {
		return x.VolumeCapability
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ControllerServiceCapability) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ControllerServiceCapability_OneofMarshaler, _ControllerServiceCapability_OneofUnmarshaler, _ControllerServiceCapability_OneofSizer, []interface{}{
		(*ControllerServiceCapability_Rpc)(nil),
		(*ControllerServiceCapability_VolumeCapability)(nil),
	}
}

func _ControllerServiceCapability_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ControllerServiceCapability)
	// type
	switch x := m.Type.(type) {
	case *ControllerServiceCapability_Rpc:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rpc); err != nil {
			return err
		}
	case *ControllerServiceCapability_VolumeCapability:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VolumeCapability); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ControllerServiceCapability.Type has unexpected type %T", x)
	}
	return nil
}

func _ControllerServiceCapability_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ControllerServiceCapability)
	switch tag {
	case 1: // type.rpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ControllerServiceCapability_RPC)
		err := b.DecodeMessage(msg)
		m.Type = &ControllerServiceCapability_Rpc{msg}
		return true, err
	case 2: // type.volume_capability
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VolumeCapability)
		err := b.DecodeMessage(msg)
		m.Type = &ControllerServiceCapability_VolumeCapability{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ControllerServiceCapability_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ControllerServiceCapability)
	// type
	switch x := m.Type.(type) {
	case *ControllerServiceCapability_Rpc:
		s := proto.Size(x.Rpc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControllerServiceCapability_VolumeCapability:
		s := proto.Size(x.VolumeCapability)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ControllerServiceCapability_RPC struct {
	Type ControllerServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=ControllerServiceCapability_RPC_Type" json:"type,omitempty"`
}

func (m *ControllerServiceCapability_RPC) Reset()      { *m = ControllerServiceCapability_RPC{} }
func (*ControllerServiceCapability_RPC) ProtoMessage() {}
func (*ControllerServiceCapability_RPC) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{29, 0}
}

func (m *ControllerServiceCapability_RPC) GetType() ControllerServiceCapability_RPC_Type {
	if m != nil {
		return m.Type
	}
	return UNKNOWN
}

type NodePublishVolumeRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The ID of the volume to publish. This field is REQUIRED.
	VolumeId *VolumeID `protobuf:"bytes,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The metadata of the volume to publish. This field is OPTIONAL.
	VolumeMetadata *VolumeMetadata `protobuf:"bytes,3,opt,name=volume_metadata,json=volumeMetadata" json:"volume_metadata,omitempty"`
	// The CO SHALL set this field to the value returned by
	// `ControllerPublishVolume` if the corresponding Controller Plugin
	// has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
	// left unset if the corresponding Controller Plugin does not have
	// this capability. This is an OPTIONAL field.
	PublishVolumeInfo *PublishVolumeInfo `protobuf:"bytes,4,opt,name=publish_volume_info,json=publishVolumeInfo" json:"publish_volume_info,omitempty"`
	// The path to which the volume will be published. It MUST be an
	// absolute path in the root filesystem of the process serving this
	// request. This is a REQUIRED field.
	TargetPath string `protobuf:"bytes,5,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// The capability of the volume to be published. This is a REQUIRED
	// field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,6,opt,name=volume_capability,json=volumeCapability" json:"volume_capability,omitempty"`
	// Whether to publish the volume in readonly mode. This field is
	// REQUIRED.
	Readonly bool `protobuf:"varint,7,opt,name=readonly,proto3" json:"readonly,omitempty"`
}

func (m *NodePublishVolumeRequest) Reset()                    { *m = NodePublishVolumeRequest{} }
func (*NodePublishVolumeRequest) ProtoMessage()               {}
func (*NodePublishVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{30} }

func (m *NodePublishVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *NodePublishVolumeRequest) GetVolumeId() *VolumeID {
	if m != nil {
		return m.VolumeId
	}
	return nil
}

func (m *NodePublishVolumeRequest) GetVolumeMetadata() *VolumeMetadata {
	if m != nil {
		return m.VolumeMetadata
	}
	return nil
}

func (m *NodePublishVolumeRequest) GetPublishVolumeInfo() *PublishVolumeInfo {
	if m != nil {
		return m.PublishVolumeInfo
	}
	return nil
}

func (m *NodePublishVolumeRequest) GetTargetPath() string {
	if m != nil {
		return m.TargetPath
	}
	return ""
}

func (m *NodePublishVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if m != nil {
		return m.VolumeCapability
	}
	return nil
}

func (m *NodePublishVolumeRequest) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type NodePublishVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*NodePublishVolumeResponse_Result_
	//	*NodePublishVolumeResponse_Error
	Reply isNodePublishVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *NodePublishVolumeResponse) Reset()                    { *m = NodePublishVolumeResponse{} }
func (*NodePublishVolumeResponse) ProtoMessage()               {}
func (*NodePublishVolumeResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{31} }

type isNodePublishVolumeResponse_Reply interface {
	isNodePublishVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodePublishVolumeResponse_Result_ struct {
	Result *NodePublishVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type NodePublishVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*NodePublishVolumeResponse_Result_) isNodePublishVolumeResponse_Reply() {}
func (*NodePublishVolumeResponse_Error) isNodePublishVolumeResponse_Reply()   {}

func (m *NodePublishVolumeResponse) GetReply() isNodePublishVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *NodePublishVolumeResponse) GetResult() *NodePublishVolumeResponse_Result {
	if x, ok := m.GetReply().(*NodePublishVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *NodePublishVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*NodePublishVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NodePublishVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NodePublishVolumeResponse_OneofMarshaler, _NodePublishVolumeResponse_OneofUnmarshaler, _NodePublishVolumeResponse_OneofSizer, []interface{}{
		(*NodePublishVolumeResponse_Result_)(nil),
		(*NodePublishVolumeResponse_Error)(nil),
	}
}

func _NodePublishVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NodePublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodePublishVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *NodePublishVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NodePublishVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _NodePublishVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NodePublishVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NodePublishVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &NodePublishVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &NodePublishVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NodePublishVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NodePublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodePublishVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NodePublishVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodePublishVolumeResponse_Result struct {
}

func (m *NodePublishVolumeResponse_Result) Reset()      { *m = NodePublishVolumeResponse_Result{} }
func (*NodePublishVolumeResponse_Result) ProtoMessage() {}
func (*NodePublishVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{31, 0}
}

type NodeUnpublishVolumeRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	// The ID of the volume. This field is REQUIRED.
	VolumeId *VolumeID `protobuf:"bytes,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The metadata of the volume. This field is OPTIONAL.
	VolumeMetadata *VolumeMetadata `protobuf:"bytes,3,opt,name=volume_metadata,json=volumeMetadata" json:"volume_metadata,omitempty"`
	// The path at which the volume was published. It MUST be an absolute
	// path in the root filesystem of the process serving this request.
	// This is a REQUIRED field.
	TargetPath string `protobuf:"bytes,4,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
}

func (m *NodeUnpublishVolumeRequest) Reset()                    { *m = NodeUnpublishVolumeRequest{} }
func (*NodeUnpublishVolumeRequest) ProtoMessage()               {}
func (*NodeUnpublishVolumeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{32} }

func (m *NodeUnpublishVolumeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *NodeUnpublishVolumeRequest) GetVolumeId() *VolumeID {
	if m != nil {
		return m.VolumeId
	}
	return nil
}

func (m *NodeUnpublishVolumeRequest) GetVolumeMetadata() *VolumeMetadata {
	if m != nil {
		return m.VolumeMetadata
	}
	return nil
}

func (m *NodeUnpublishVolumeRequest) GetTargetPath() string {
	if m != nil {
		return m.TargetPath
	}
	return ""
}

type NodeUnpublishVolumeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*NodeUnpublishVolumeResponse_Result_
	//	*NodeUnpublishVolumeResponse_Error
	Reply isNodeUnpublishVolumeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *NodeUnpublishVolumeResponse) Reset()                    { *m = NodeUnpublishVolumeResponse{} }
func (*NodeUnpublishVolumeResponse) ProtoMessage()               {}
func (*NodeUnpublishVolumeResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{33} }

type isNodeUnpublishVolumeResponse_Reply interface {
	isNodeUnpublishVolumeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodeUnpublishVolumeResponse_Result_ struct {
	Result *NodeUnpublishVolumeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type NodeUnpublishVolumeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*NodeUnpublishVolumeResponse_Result_) isNodeUnpublishVolumeResponse_Reply() {}
func (*NodeUnpublishVolumeResponse_Error) isNodeUnpublishVolumeResponse_Reply()   {}

func (m *NodeUnpublishVolumeResponse) GetReply() isNodeUnpublishVolumeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *NodeUnpublishVolumeResponse) GetResult() *NodeUnpublishVolumeResponse_Result {
	if x, ok := m.GetReply().(*NodeUnpublishVolumeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *NodeUnpublishVolumeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*NodeUnpublishVolumeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NodeUnpublishVolumeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NodeUnpublishVolumeResponse_OneofMarshaler, _NodeUnpublishVolumeResponse_OneofUnmarshaler, _NodeUnpublishVolumeResponse_OneofSizer, []interface{}{
		(*NodeUnpublishVolumeResponse_Result_)(nil),
		(*NodeUnpublishVolumeResponse_Error)(nil),
	}
}

func _NodeUnpublishVolumeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NodeUnpublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodeUnpublishVolumeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *NodeUnpublishVolumeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NodeUnpublishVolumeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _NodeUnpublishVolumeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NodeUnpublishVolumeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NodeUnpublishVolumeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &NodeUnpublishVolumeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &NodeUnpublishVolumeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NodeUnpublishVolumeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NodeUnpublishVolumeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodeUnpublishVolumeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NodeUnpublishVolumeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodeUnpublishVolumeResponse_Result struct {
}

func (m *NodeUnpublishVolumeResponse_Result) Reset()      { *m = NodeUnpublishVolumeResponse_Result{} }
func (*NodeUnpublishVolumeResponse_Result) ProtoMessage() {}
func (*NodeUnpublishVolumeResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{33, 0}
}

type GetNodeIDRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *GetNodeIDRequest) Reset()                    { *m = GetNodeIDRequest{} }
func (*GetNodeIDRequest) ProtoMessage()               {}
func (*GetNodeIDRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{34} }

func (m *GetNodeIDRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type GetNodeIDResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*GetNodeIDResponse_Result_
	//	*GetNodeIDResponse_Error
	Reply isGetNodeIDResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GetNodeIDResponse) Reset()                    { *m = GetNodeIDResponse{} }
func (*GetNodeIDResponse) ProtoMessage()               {}
func (*GetNodeIDResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{35} }

type isGetNodeIDResponse_Reply interface {
	isGetNodeIDResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetNodeIDResponse_Result_ struct {
	Result *GetNodeIDResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GetNodeIDResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GetNodeIDResponse_Result_) isGetNodeIDResponse_Reply() {}
func (*GetNodeIDResponse_Error) isGetNodeIDResponse_Reply()   {}

func (m *GetNodeIDResponse) GetReply() isGetNodeIDResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GetNodeIDResponse) GetResult() *GetNodeIDResponse_Result {
	if x, ok := m.GetReply().(*GetNodeIDResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GetNodeIDResponse) GetError() *Error {
	if x, ok := m.GetReply().(*GetNodeIDResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetNodeIDResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetNodeIDResponse_OneofMarshaler, _GetNodeIDResponse_OneofUnmarshaler, _GetNodeIDResponse_OneofSizer, []interface{}{
		(*GetNodeIDResponse_Result_)(nil),
		(*GetNodeIDResponse_Error)(nil),
	}
}

func _GetNodeIDResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetNodeIDResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetNodeIDResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GetNodeIDResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetNodeIDResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GetNodeIDResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetNodeIDResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetNodeIDResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GetNodeIDResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GetNodeIDResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetNodeIDResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetNodeIDResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GetNodeIDResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetNodeIDResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetNodeIDResponse_Result struct {
	// The ID of the node which SHALL be used by CO in
	// `ControllerPublishVolume`. This is an OPTIONAL field. If unset,
	// the CO SHALL leave the `node_id` field unset in
	// `ControllerPublishVolume`.
	NodeId *NodeID `protobuf:"bytes,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
}

func (m *GetNodeIDResponse_Result) Reset()                    { *m = GetNodeIDResponse_Result{} }
func (*GetNodeIDResponse_Result) ProtoMessage()               {}
func (*GetNodeIDResponse_Result) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{35, 0} }

func (m *GetNodeIDResponse_Result) GetNodeId() *NodeID {
	if m != nil {
		return m.NodeId
	}
	return nil
}

type ProbeNodeRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *ProbeNodeRequest) Reset()                    { *m = ProbeNodeRequest{} }
func (*ProbeNodeRequest) ProtoMessage()               {}
func (*ProbeNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{36} }

func (m *ProbeNodeRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type ProbeNodeResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*ProbeNodeResponse_Result_
	//	*ProbeNodeResponse_Error
	Reply isProbeNodeResponse_Reply `protobuf_oneof:"reply"`
}

func (m *ProbeNodeResponse) Reset()                    { *m = ProbeNodeResponse{} }
func (*ProbeNodeResponse) ProtoMessage()               {}
func (*ProbeNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{37} }

type isProbeNodeResponse_Reply interface {
	isProbeNodeResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProbeNodeResponse_Result_ struct {
	Result *ProbeNodeResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type ProbeNodeResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*ProbeNodeResponse_Result_) isProbeNodeResponse_Reply() {}
func (*ProbeNodeResponse_Error) isProbeNodeResponse_Reply()   {}

func (m *ProbeNodeResponse) GetReply() isProbeNodeResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ProbeNodeResponse) GetResult() *ProbeNodeResponse_Result {
	if x, ok := m.GetReply().(*ProbeNodeResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *ProbeNodeResponse) GetError() *Error {
	if x, ok := m.GetReply().(*ProbeNodeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProbeNodeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProbeNodeResponse_OneofMarshaler, _ProbeNodeResponse_OneofUnmarshaler, _ProbeNodeResponse_OneofSizer, []interface{}{
		(*ProbeNodeResponse_Result_)(nil),
		(*ProbeNodeResponse_Error)(nil),
	}
}

func _ProbeNodeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProbeNodeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ProbeNodeResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *ProbeNodeResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProbeNodeResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _ProbeNodeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProbeNodeResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProbeNodeResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &ProbeNodeResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &ProbeNodeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProbeNodeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProbeNodeResponse)
	// reply
	switch x := m.Reply.(type) {
	case *ProbeNodeResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProbeNodeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ProbeNodeResponse_Result struct {
}

func (m *ProbeNodeResponse_Result) Reset()                    { *m = ProbeNodeResponse_Result{} }
func (*ProbeNodeResponse_Result) ProtoMessage()               {}
func (*ProbeNodeResponse_Result) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{37, 0} }

type NodeGetCapabilitiesRequest struct {
	// The API version assumed by the CO. This is a REQUIRED field.
	Version *Version `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *NodeGetCapabilitiesRequest) Reset()                    { *m = NodeGetCapabilitiesRequest{} }
func (*NodeGetCapabilitiesRequest) ProtoMessage()               {}
func (*NodeGetCapabilitiesRequest) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{38} }

func (m *NodeGetCapabilitiesRequest) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

type NodeGetCapabilitiesResponse struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Reply:
	//	*NodeGetCapabilitiesResponse_Result_
	//	*NodeGetCapabilitiesResponse_Error
	Reply isNodeGetCapabilitiesResponse_Reply `protobuf_oneof:"reply"`
}

func (m *NodeGetCapabilitiesResponse) Reset()                    { *m = NodeGetCapabilitiesResponse{} }
func (*NodeGetCapabilitiesResponse) ProtoMessage()               {}
func (*NodeGetCapabilitiesResponse) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{39} }

type isNodeGetCapabilitiesResponse_Reply interface {
	isNodeGetCapabilitiesResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodeGetCapabilitiesResponse_Result_ struct {
	Result *NodeGetCapabilitiesResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type NodeGetCapabilitiesResponse_Error struct {
	Error *Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*NodeGetCapabilitiesResponse_Result_) isNodeGetCapabilitiesResponse_Reply() {}
func (*NodeGetCapabilitiesResponse_Error) isNodeGetCapabilitiesResponse_Reply()   {}

func (m *NodeGetCapabilitiesResponse) GetReply() isNodeGetCapabilitiesResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *NodeGetCapabilitiesResponse) GetResult() *NodeGetCapabilitiesResponse_Result {
	if x, ok := m.GetReply().(*NodeGetCapabilitiesResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *NodeGetCapabilitiesResponse) GetError() *Error {
	if x, ok := m.GetReply().(*NodeGetCapabilitiesResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NodeGetCapabilitiesResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NodeGetCapabilitiesResponse_OneofMarshaler, _NodeGetCapabilitiesResponse_OneofUnmarshaler, _NodeGetCapabilitiesResponse_OneofSizer, []interface{}{
		(*NodeGetCapabilitiesResponse_Result_)(nil),
		(*NodeGetCapabilitiesResponse_Error)(nil),
	}
}

func _NodeGetCapabilitiesResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NodeGetCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodeGetCapabilitiesResponse_Result_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *NodeGetCapabilitiesResponse_Error:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NodeGetCapabilitiesResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _NodeGetCapabilitiesResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NodeGetCapabilitiesResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NodeGetCapabilitiesResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &NodeGetCapabilitiesResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Reply = &NodeGetCapabilitiesResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NodeGetCapabilitiesResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NodeGetCapabilitiesResponse)
	// reply
	switch x := m.Reply.(type) {
	case *NodeGetCapabilitiesResponse_Result_:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NodeGetCapabilitiesResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodeGetCapabilitiesResponse_Result struct {
	// All the capabilities that the node service supports. This field
	// is OPTIONAL.
	Capabilities []*NodeServiceCapability `protobuf:"bytes,2,rep,name=capabilities" json:"capabilities,omitempty"`
}

func (m *NodeGetCapabilitiesResponse_Result) Reset()      { *m = NodeGetCapabilitiesResponse_Result{} }
func (*NodeGetCapabilitiesResponse_Result) ProtoMessage() {}
func (*NodeGetCapabilitiesResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{39, 0}
}

func (m *NodeGetCapabilitiesResponse_Result) GetCapabilities() []*NodeServiceCapability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Specifies a capability of the node service.
type NodeServiceCapability struct {
	// Types that are valid to be assigned to Type:
	//	*NodeServiceCapability_Rpc
	//	*NodeServiceCapability_VolumeCapability
	Type isNodeServiceCapability_Type `protobuf_oneof:"type"`
}

func (m *NodeServiceCapability) Reset()                    { *m = NodeServiceCapability{} }
func (*NodeServiceCapability) ProtoMessage()               {}
func (*NodeServiceCapability) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{40} }

type isNodeServiceCapability_Type interface {
	isNodeServiceCapability_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NodeServiceCapability_Rpc struct {
	Rpc *NodeServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,oneof"`
}
type NodeServiceCapability_VolumeCapability struct {
	VolumeCapability *VolumeCapability `protobuf:"bytes,2,opt,name=volume_capability,json=volumeCapability,oneof"`
}

func (*NodeServiceCapability_Rpc) isNodeServiceCapability_Type()              {}
func (*NodeServiceCapability_VolumeCapability) isNodeServiceCapability_Type() {}

func (m *NodeServiceCapability) GetType() isNodeServiceCapability_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *NodeServiceCapability) GetRpc() *NodeServiceCapability_RPC {
	if x, ok := m.GetType().(*NodeServiceCapability_Rpc); ok {
		return x.Rpc
	}
	return nil
}

func (m *NodeServiceCapability) GetVolumeCapability() *VolumeCapability {
	if x, ok := m.GetType().(*NodeServiceCapability_VolumeCapability); ok {
		return x.VolumeCapability
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NodeServiceCapability) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NodeServiceCapability_OneofMarshaler, _NodeServiceCapability_OneofUnmarshaler, _NodeServiceCapability_OneofSizer, []interface{}{
		(*NodeServiceCapability_Rpc)(nil),
		(*NodeServiceCapability_VolumeCapability)(nil),
	}
}

func _NodeServiceCapability_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NodeServiceCapability)
	// type
	switch x := m.Type.(type) {
	case *NodeServiceCapability_Rpc:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rpc); err != nil {
			return err
		}
	case *NodeServiceCapability_VolumeCapability:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VolumeCapability); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NodeServiceCapability.Type has unexpected type %T", x)
	}
	return nil
}

func _NodeServiceCapability_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NodeServiceCapability)
	switch tag {
	case 1: // type.rpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NodeServiceCapability_RPC)
		err := b.DecodeMessage(msg)
		m.Type = &NodeServiceCapability_Rpc{msg}
		return true, err
	case 2: // type.volume_capability
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VolumeCapability)
		err := b.DecodeMessage(msg)
		m.Type = &NodeServiceCapability_VolumeCapability{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NodeServiceCapability_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NodeServiceCapability)
	// type
	switch x := m.Type.(type) {
	case *NodeServiceCapability_Rpc:
		s := proto.Size(x.Rpc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NodeServiceCapability_VolumeCapability:
		s := proto.Size(x.VolumeCapability)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodeServiceCapability_RPC struct {
	Type NodeServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=NodeServiceCapability_RPC_Type" json:"type,omitempty"`
}

func (m *NodeServiceCapability_RPC) Reset()                    { *m = NodeServiceCapability_RPC{} }
func (*NodeServiceCapability_RPC) ProtoMessage()               {}
func (*NodeServiceCapability_RPC) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{40, 0} }

func (m *NodeServiceCapability_RPC) GetType() NodeServiceCapability_RPC_Type {
	if m != nil {
		return m.Type
	}
	return UNKNOWN
}

type Error struct {
	// One of the following fields MUST be specified.
	//
	// Types that are valid to be assigned to Value:
	//	*Error_GeneralError_
	//	*Error_CreateVolumeError_
	//	*Error_DeleteVolumeError_
	//	*Error_ControllerPublishVolumeVolumeError
	//	*Error_ControllerUnpublishVolumeVolumeError
	//	*Error_ValidateVolumeCapabilitiesError_
	//	*Error_NodePublishVolumeError_
	//	*Error_NodeUnpublishVolumeError_
	//	*Error_ProbeNodeError_
	Value isError_Value `protobuf_oneof:"value"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41} }

type isError_Value interface {
	isError_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Error_GeneralError_ struct {
	GeneralError *Error_GeneralError `protobuf:"bytes,1,opt,name=general_error,json=generalError,oneof"`
}
type Error_CreateVolumeError_ struct {
	CreateVolumeError *Error_CreateVolumeError `protobuf:"bytes,2,opt,name=create_volume_error,json=createVolumeError,oneof"`
}
type Error_DeleteVolumeError_ struct {
	DeleteVolumeError *Error_DeleteVolumeError `protobuf:"bytes,3,opt,name=delete_volume_error,json=deleteVolumeError,oneof"`
}
type Error_ControllerPublishVolumeVolumeError struct {
	ControllerPublishVolumeVolumeError *Error_ControllerPublishVolumeError `protobuf:"bytes,4,opt,name=controller_publish_volume_volume_error,json=controllerPublishVolumeVolumeError,oneof"`
}
type Error_ControllerUnpublishVolumeVolumeError struct {
	ControllerUnpublishVolumeVolumeError *Error_ControllerUnpublishVolumeError `protobuf:"bytes,5,opt,name=controller_unpublish_volume_volume_error,json=controllerUnpublishVolumeVolumeError,oneof"`
}
type Error_ValidateVolumeCapabilitiesError_ struct {
	ValidateVolumeCapabilitiesError *Error_ValidateVolumeCapabilitiesError `protobuf:"bytes,6,opt,name=validate_volume_capabilities_error,json=validateVolumeCapabilitiesError,oneof"`
}
type Error_NodePublishVolumeError_ struct {
	NodePublishVolumeError *Error_NodePublishVolumeError `protobuf:"bytes,7,opt,name=node_publish_volume_error,json=nodePublishVolumeError,oneof"`
}
type Error_NodeUnpublishVolumeError_ struct {
	NodeUnpublishVolumeError *Error_NodeUnpublishVolumeError `protobuf:"bytes,8,opt,name=node_unpublish_volume_error,json=nodeUnpublishVolumeError,oneof"`
}
type Error_ProbeNodeError_ struct {
	ProbeNodeError *Error_ProbeNodeError `protobuf:"bytes,9,opt,name=probe_node_error,json=probeNodeError,oneof"`
}

func (*Error_GeneralError_) isError_Value()                        {}
func (*Error_CreateVolumeError_) isError_Value()                   {}
func (*Error_DeleteVolumeError_) isError_Value()                   {}
func (*Error_ControllerPublishVolumeVolumeError) isError_Value()   {}
func (*Error_ControllerUnpublishVolumeVolumeError) isError_Value() {}
func (*Error_ValidateVolumeCapabilitiesError_) isError_Value()     {}
func (*Error_NodePublishVolumeError_) isError_Value()              {}
func (*Error_NodeUnpublishVolumeError_) isError_Value()            {}
func (*Error_ProbeNodeError_) isError_Value()                      {}

func (m *Error) GetValue() isError_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Error) GetGeneralError() *Error_GeneralError {
	if x, ok := m.GetValue().(*Error_GeneralError_); ok {
		return x.GeneralError
	}
	return nil
}

func (m *Error) GetCreateVolumeError() *Error_CreateVolumeError {
	if x, ok := m.GetValue().(*Error_CreateVolumeError_); ok {
		return x.CreateVolumeError
	}
	return nil
}

func (m *Error) GetDeleteVolumeError() *Error_DeleteVolumeError {
	if x, ok := m.GetValue().(*Error_DeleteVolumeError_); ok {
		return x.DeleteVolumeError
	}
	return nil
}

func (m *Error) GetControllerPublishVolumeVolumeError() *Error_ControllerPublishVolumeError {
	if x, ok := m.GetValue().(*Error_ControllerPublishVolumeVolumeError); ok {
		return x.ControllerPublishVolumeVolumeError
	}
	return nil
}

func (m *Error) GetControllerUnpublishVolumeVolumeError() *Error_ControllerUnpublishVolumeError {
	if x, ok := m.GetValue().(*Error_ControllerUnpublishVolumeVolumeError); ok {
		return x.ControllerUnpublishVolumeVolumeError
	}
	return nil
}

func (m *Error) GetValidateVolumeCapabilitiesError() *Error_ValidateVolumeCapabilitiesError {
	if x, ok := m.GetValue().(*Error_ValidateVolumeCapabilitiesError_); ok {
		return x.ValidateVolumeCapabilitiesError
	}
	return nil
}

func (m *Error) GetNodePublishVolumeError() *Error_NodePublishVolumeError {
	if x, ok := m.GetValue().(*Error_NodePublishVolumeError_); ok {
		return x.NodePublishVolumeError
	}
	return nil
}

func (m *Error) GetNodeUnpublishVolumeError() *Error_NodeUnpublishVolumeError {
	if x, ok := m.GetValue().(*Error_NodeUnpublishVolumeError_); ok {
		return x.NodeUnpublishVolumeError
	}
	return nil
}

func (m *Error) GetProbeNodeError() *Error_ProbeNodeError {
	if x, ok := m.GetValue().(*Error_ProbeNodeError_); ok {
		return x.ProbeNodeError
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Error) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Error_OneofMarshaler, _Error_OneofUnmarshaler, _Error_OneofSizer, []interface{}{
		(*Error_GeneralError_)(nil),
		(*Error_CreateVolumeError_)(nil),
		(*Error_DeleteVolumeError_)(nil),
		(*Error_ControllerPublishVolumeVolumeError)(nil),
		(*Error_ControllerUnpublishVolumeVolumeError)(nil),
		(*Error_ValidateVolumeCapabilitiesError_)(nil),
		(*Error_NodePublishVolumeError_)(nil),
		(*Error_NodeUnpublishVolumeError_)(nil),
		(*Error_ProbeNodeError_)(nil),
	}
}

func _Error_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Error)
	// value
	switch x := m.Value.(type) {
	case *Error_GeneralError_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneralError); err != nil {
			return err
		}
	case *Error_CreateVolumeError_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateVolumeError); err != nil {
			return err
		}
	case *Error_DeleteVolumeError_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeleteVolumeError); err != nil {
			return err
		}
	case *Error_ControllerPublishVolumeVolumeError:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ControllerPublishVolumeVolumeError); err != nil {
			return err
		}
	case *Error_ControllerUnpublishVolumeVolumeError:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ControllerUnpublishVolumeVolumeError); err != nil {
			return err
		}
	case *Error_ValidateVolumeCapabilitiesError_:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ValidateVolumeCapabilitiesError); err != nil {
			return err
		}
	case *Error_NodePublishVolumeError_:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NodePublishVolumeError); err != nil {
			return err
		}
	case *Error_NodeUnpublishVolumeError_:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NodeUnpublishVolumeError); err != nil {
			return err
		}
	case *Error_ProbeNodeError_:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProbeNodeError); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Error.Value has unexpected type %T", x)
	}
	return nil
}

func _Error_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Error)
	switch tag {
	case 1: // value.general_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_GeneralError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_GeneralError_{msg}
		return true, err
	case 2: // value.create_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_CreateVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_CreateVolumeError_{msg}
		return true, err
	case 3: // value.delete_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_DeleteVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_DeleteVolumeError_{msg}
		return true, err
	case 4: // value.controller_publish_volume_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_ControllerPublishVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_ControllerPublishVolumeVolumeError{msg}
		return true, err
	case 5: // value.controller_unpublish_volume_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_ControllerUnpublishVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_ControllerUnpublishVolumeVolumeError{msg}
		return true, err
	case 6: // value.validate_volume_capabilities_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_ValidateVolumeCapabilitiesError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_ValidateVolumeCapabilitiesError_{msg}
		return true, err
	case 7: // value.node_publish_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_NodePublishVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_NodePublishVolumeError_{msg}
		return true, err
	case 8: // value.node_unpublish_volume_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_NodeUnpublishVolumeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_NodeUnpublishVolumeError_{msg}
		return true, err
	case 9: // value.probe_node_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error_ProbeNodeError)
		err := b.DecodeMessage(msg)
		m.Value = &Error_ProbeNodeError_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Error_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Error)
	// value
	switch x := m.Value.(type) {
	case *Error_GeneralError_:
		s := proto.Size(x.GeneralError)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_CreateVolumeError_:
		s := proto.Size(x.CreateVolumeError)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_DeleteVolumeError_:
		s := proto.Size(x.DeleteVolumeError)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_ControllerPublishVolumeVolumeError:
		s := proto.Size(x.ControllerPublishVolumeVolumeError)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_ControllerUnpublishVolumeVolumeError:
		s := proto.Size(x.ControllerUnpublishVolumeVolumeError)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_ValidateVolumeCapabilitiesError_:
		s := proto.Size(x.ValidateVolumeCapabilitiesError)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_NodePublishVolumeError_:
		s := proto.Size(x.NodePublishVolumeError)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_NodeUnpublishVolumeError_:
		s := proto.Size(x.NodeUnpublishVolumeError)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Error_ProbeNodeError_:
		s := proto.Size(x.ProbeNodeError)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// General Error that MAY be returned by any RPC.
type Error_GeneralError struct {
	// Machine parsable error code.
	ErrorCode Error_GeneralError_GeneralErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_GeneralError_GeneralErrorCode" json:"error_code,omitempty"`
	// When set to true, `caller_must_not_retry` indicates that the
	// caller MUST not retry the same call again. This MAY be because
	// the call is deemed invalid by the Plugin and no amount of retries
	// will cause it to succeed. If this value is false, the caller MAY
	// reissue the same call, but SHOULD implement exponential backoff
	// on retires.
	CallerMustNotRetry bool `protobuf:"varint,2,opt,name=caller_must_not_retry,json=callerMustNotRetry,proto3" json:"caller_must_not_retry,omitempty"`
	// Human readable description of error, possibly with additional
	// information. This string MAY be surfaced by CO to end users.
	ErrorDescription string `protobuf:"bytes,3,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_GeneralError) Reset()                    { *m = Error_GeneralError{} }
func (*Error_GeneralError) ProtoMessage()               {}
func (*Error_GeneralError) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41, 0} }

func (m *Error_GeneralError) GetErrorCode() Error_GeneralError_GeneralErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_GeneralError) GetCallerMustNotRetry() bool {
	if m != nil {
		return m.CallerMustNotRetry
	}
	return false
}

func (m *Error_GeneralError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `CreateVolume` specific error.
type Error_CreateVolumeError struct {
	// Machine parsable error code.
	ErrorCode Error_CreateVolumeError_CreateVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_CreateVolumeError_CreateVolumeErrorCode" json:"error_code,omitempty"`
	// Human readable description of error, possibly with additional
	// information. This string maybe surfaced by CO to end users.
	ErrorDescription string `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_CreateVolumeError) Reset()                    { *m = Error_CreateVolumeError{} }
func (*Error_CreateVolumeError) ProtoMessage()               {}
func (*Error_CreateVolumeError) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41, 1} }

func (m *Error_CreateVolumeError) GetErrorCode() Error_CreateVolumeError_CreateVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_CreateVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `DeleteVolume` specific error.
type Error_DeleteVolumeError struct {
	// Machine parsable error code.
	ErrorCode Error_DeleteVolumeError_DeleteVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_DeleteVolumeError_DeleteVolumeErrorCode" json:"error_code,omitempty"`
	// Human readable description of error, possibly with additional
	// information. This string maybe surfaced by CO to end users.
	ErrorDescription string `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_DeleteVolumeError) Reset()                    { *m = Error_DeleteVolumeError{} }
func (*Error_DeleteVolumeError) ProtoMessage()               {}
func (*Error_DeleteVolumeError) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41, 2} }

func (m *Error_DeleteVolumeError) GetErrorCode() Error_DeleteVolumeError_DeleteVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_DeleteVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `ControllerPublishVolume` specific error.
type Error_ControllerPublishVolumeError struct {
	// Machine parsable error code.
	ErrorCode Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode" json:"error_code,omitempty"`
	// Human readable description of error, possibly with additional
	// information. This string maybe surfaced by CO to end users.
	ErrorDescription string `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
	// On `VOLUME_ALREADY_ATTACHED` and `MAX_ATTACHED_NODES` errors,
	// this field contains the node(s) that the specified volume is
	// already attached to.
	NodeIds []*NodeID `protobuf:"bytes,3,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
}

func (m *Error_ControllerPublishVolumeError) Reset()      { *m = Error_ControllerPublishVolumeError{} }
func (*Error_ControllerPublishVolumeError) ProtoMessage() {}
func (*Error_ControllerPublishVolumeError) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 3}
}

func (m *Error_ControllerPublishVolumeError) GetErrorCode() Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_ControllerPublishVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func (m *Error_ControllerPublishVolumeError) GetNodeIds() []*NodeID {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

// `ControllerUnpublishVolume` specific error.
type Error_ControllerUnpublishVolumeError struct {
	ErrorCode        Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                                                  `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_ControllerUnpublishVolumeError) Reset()      { *m = Error_ControllerUnpublishVolumeError{} }
func (*Error_ControllerUnpublishVolumeError) ProtoMessage() {}
func (*Error_ControllerUnpublishVolumeError) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 4}
}

func (m *Error_ControllerUnpublishVolumeError) GetErrorCode() Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_ControllerUnpublishVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `ValidateVolumeCapabilities` specific error.
type Error_ValidateVolumeCapabilitiesError struct {
	ErrorCode        Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                                                    `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_ValidateVolumeCapabilitiesError) Reset()      { *m = Error_ValidateVolumeCapabilitiesError{} }
func (*Error_ValidateVolumeCapabilitiesError) ProtoMessage() {}
func (*Error_ValidateVolumeCapabilitiesError) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 5}
}

func (m *Error_ValidateVolumeCapabilitiesError) GetErrorCode() Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_ValidateVolumeCapabilitiesError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `NodePublishVolume` specific error.
type Error_NodePublishVolumeError struct {
	ErrorCode        Error_NodePublishVolumeError_NodePublishVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_NodePublishVolumeError_NodePublishVolumeErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                                  `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_NodePublishVolumeError) Reset()      { *m = Error_NodePublishVolumeError{} }
func (*Error_NodePublishVolumeError) ProtoMessage() {}
func (*Error_NodePublishVolumeError) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 6}
}

func (m *Error_NodePublishVolumeError) GetErrorCode() Error_NodePublishVolumeError_NodePublishVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_NodePublishVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `NodeUnpublishVolume` specific error.
type Error_NodeUnpublishVolumeError struct {
	ErrorCode        Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                                      `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_NodeUnpublishVolumeError) Reset()      { *m = Error_NodeUnpublishVolumeError{} }
func (*Error_NodeUnpublishVolumeError) ProtoMessage() {}
func (*Error_NodeUnpublishVolumeError) Descriptor() ([]byte, []int) {
	return fileDescriptorCsi, []int{41, 7}
}

func (m *Error_NodeUnpublishVolumeError) GetErrorCode() Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_NodeUnpublishVolumeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `ProbeNode` specific error.
type Error_ProbeNodeError struct {
	ErrorCode        Error_ProbeNodeError_ProbeNodeErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_ProbeNodeError_ProbeNodeErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                  `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_ProbeNodeError) Reset()                    { *m = Error_ProbeNodeError{} }
func (*Error_ProbeNodeError) ProtoMessage()               {}
func (*Error_ProbeNodeError) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41, 8} }

func (m *Error_ProbeNodeError) GetErrorCode() Error_ProbeNodeError_ProbeNodeErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_ProbeNodeError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

// `GetNodeID` specific error.
type Error_GetNodeIDError struct {
	ErrorCode        Error_GetNodeIDError_GetNodeIDErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=Error_GetNodeIDError_GetNodeIDErrorCode" json:"error_code,omitempty"`
	ErrorDescription string                                  `protobuf:"bytes,2,opt,name=error_description,json=errorDescription,proto3" json:"error_description,omitempty"`
}

func (m *Error_GetNodeIDError) Reset()                    { *m = Error_GetNodeIDError{} }
func (*Error_GetNodeIDError) ProtoMessage()               {}
func (*Error_GetNodeIDError) Descriptor() ([]byte, []int) { return fileDescriptorCsi, []int{41, 9} }

func (m *Error_GetNodeIDError) GetErrorCode() Error_GetNodeIDError_GetNodeIDErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return UNKNOWN
}

func (m *Error_GetNodeIDError) GetErrorDescription() string {
	if m != nil {
		return m.ErrorDescription
	}
	return ""
}

func init() {
	proto.RegisterType((*GetSupportedVersionsRequest)(nil), "GetSupportedVersionsRequest")
	proto.RegisterType((*GetSupportedVersionsResponse)(nil), "GetSupportedVersionsResponse")
	proto.RegisterType((*GetSupportedVersionsResponse_Result)(nil), "GetSupportedVersionsResponse.Result")
	proto.RegisterType((*Version)(nil), "Version")
	proto.RegisterType((*GetPluginInfoRequest)(nil), "GetPluginInfoRequest")
	proto.RegisterType((*GetPluginInfoResponse)(nil), "GetPluginInfoResponse")
	proto.RegisterType((*GetPluginInfoResponse_Result)(nil), "GetPluginInfoResponse.Result")
	proto.RegisterType((*CreateVolumeRequest)(nil), "CreateVolumeRequest")
	proto.RegisterType((*CreateVolumeResponse)(nil), "CreateVolumeResponse")
	proto.RegisterType((*CreateVolumeResponse_Result)(nil), "CreateVolumeResponse.Result")
	proto.RegisterType((*VolumeCapability)(nil), "VolumeCapability")
	proto.RegisterType((*VolumeCapability_BlockVolume)(nil), "VolumeCapability.BlockVolume")
	proto.RegisterType((*VolumeCapability_MountVolume)(nil), "VolumeCapability.MountVolume")
	proto.RegisterType((*CapacityRange)(nil), "CapacityRange")
	proto.RegisterType((*VolumeInfo)(nil), "VolumeInfo")
	proto.RegisterType((*AccessMode)(nil), "AccessMode")
	proto.RegisterType((*VolumeID)(nil), "VolumeID")
	proto.RegisterType((*VolumeMetadata)(nil), "VolumeMetadata")
	proto.RegisterType((*DeleteVolumeRequest)(nil), "DeleteVolumeRequest")
	proto.RegisterType((*DeleteVolumeResponse)(nil), "DeleteVolumeResponse")
	proto.RegisterType((*DeleteVolumeResponse_Result)(nil), "DeleteVolumeResponse.Result")
	proto.RegisterType((*ControllerPublishVolumeRequest)(nil), "ControllerPublishVolumeRequest")
	proto.RegisterType((*ControllerPublishVolumeResponse)(nil), "ControllerPublishVolumeResponse")
	proto.RegisterType((*ControllerPublishVolumeResponse_Result)(nil), "ControllerPublishVolumeResponse.Result")
	proto.RegisterType((*NodeID)(nil), "NodeID")
	proto.RegisterType((*PublishVolumeInfo)(nil), "PublishVolumeInfo")
	proto.RegisterType((*ControllerUnpublishVolumeRequest)(nil), "ControllerUnpublishVolumeRequest")
	proto.RegisterType((*ControllerUnpublishVolumeResponse)(nil), "ControllerUnpublishVolumeResponse")
	proto.RegisterType((*ControllerUnpublishVolumeResponse_Result)(nil), "ControllerUnpublishVolumeResponse.Result")
	proto.RegisterType((*ValidateVolumeCapabilitiesRequest)(nil), "ValidateVolumeCapabilitiesRequest")
	proto.RegisterType((*ValidateVolumeCapabilitiesResponse)(nil), "ValidateVolumeCapabilitiesResponse")
	proto.RegisterType((*ValidateVolumeCapabilitiesResponse_Result)(nil), "ValidateVolumeCapabilitiesResponse.Result")
	proto.RegisterType((*ListVolumesRequest)(nil), "ListVolumesRequest")
	proto.RegisterType((*ListVolumesResponse)(nil), "ListVolumesResponse")
	proto.RegisterType((*ListVolumesResponse_Result)(nil), "ListVolumesResponse.Result")
	proto.RegisterType((*ListVolumesResponse_Result_Entry)(nil), "ListVolumesResponse.Result.Entry")
	proto.RegisterType((*GetCapacityRequest)(nil), "GetCapacityRequest")
	proto.RegisterType((*GetCapacityResponse)(nil), "GetCapacityResponse")
	proto.RegisterType((*GetCapacityResponse_Result)(nil), "GetCapacityResponse.Result")
	proto.RegisterType((*ControllerGetCapabilitiesRequest)(nil), "ControllerGetCapabilitiesRequest")
	proto.RegisterType((*ControllerGetCapabilitiesResponse)(nil), "ControllerGetCapabilitiesResponse")
	proto.RegisterType((*ControllerGetCapabilitiesResponse_Result)(nil), "ControllerGetCapabilitiesResponse.Result")
	proto.RegisterType((*ControllerServiceCapability)(nil), "ControllerServiceCapability")
	proto.RegisterType((*ControllerServiceCapability_RPC)(nil), "ControllerServiceCapability.RPC")
	proto.RegisterType((*NodePublishVolumeRequest)(nil), "NodePublishVolumeRequest")
	proto.RegisterType((*NodePublishVolumeResponse)(nil), "NodePublishVolumeResponse")
	proto.RegisterType((*NodePublishVolumeResponse_Result)(nil), "NodePublishVolumeResponse.Result")
	proto.RegisterType((*NodeUnpublishVolumeRequest)(nil), "NodeUnpublishVolumeRequest")
	proto.RegisterType((*NodeUnpublishVolumeResponse)(nil), "NodeUnpublishVolumeResponse")
	proto.RegisterType((*NodeUnpublishVolumeResponse_Result)(nil), "NodeUnpublishVolumeResponse.Result")
	proto.RegisterType((*GetNodeIDRequest)(nil), "GetNodeIDRequest")
	proto.RegisterType((*GetNodeIDResponse)(nil), "GetNodeIDResponse")
	proto.RegisterType((*GetNodeIDResponse_Result)(nil), "GetNodeIDResponse.Result")
	proto.RegisterType((*ProbeNodeRequest)(nil), "ProbeNodeRequest")
	proto.RegisterType((*ProbeNodeResponse)(nil), "ProbeNodeResponse")
	proto.RegisterType((*ProbeNodeResponse_Result)(nil), "ProbeNodeResponse.Result")
	proto.RegisterType((*NodeGetCapabilitiesRequest)(nil), "NodeGetCapabilitiesRequest")
	proto.RegisterType((*NodeGetCapabilitiesResponse)(nil), "NodeGetCapabilitiesResponse")
	proto.RegisterType((*NodeGetCapabilitiesResponse_Result)(nil), "NodeGetCapabilitiesResponse.Result")
	proto.RegisterType((*NodeServiceCapability)(nil), "NodeServiceCapability")
	proto.RegisterType((*NodeServiceCapability_RPC)(nil), "NodeServiceCapability.RPC")
	proto.RegisterType((*Error)(nil), "Error")
	proto.RegisterType((*Error_GeneralError)(nil), "Error.GeneralError")
	proto.RegisterType((*Error_CreateVolumeError)(nil), "Error.CreateVolumeError")
	proto.RegisterType((*Error_DeleteVolumeError)(nil), "Error.DeleteVolumeError")
	proto.RegisterType((*Error_ControllerPublishVolumeError)(nil), "Error.ControllerPublishVolumeError")
	proto.RegisterType((*Error_ControllerUnpublishVolumeError)(nil), "Error.ControllerUnpublishVolumeError")
	proto.RegisterType((*Error_ValidateVolumeCapabilitiesError)(nil), "Error.ValidateVolumeCapabilitiesError")
	proto.RegisterType((*Error_NodePublishVolumeError)(nil), "Error.NodePublishVolumeError")
	proto.RegisterType((*Error_NodeUnpublishVolumeError)(nil), "Error.NodeUnpublishVolumeError")
	proto.RegisterType((*Error_ProbeNodeError)(nil), "Error.ProbeNodeError")
	proto.RegisterType((*Error_GetNodeIDError)(nil), "Error.GetNodeIDError")
	proto.RegisterEnum("AccessMode_Mode", AccessMode_Mode_name, AccessMode_Mode_value)
	proto.RegisterEnum("ControllerServiceCapability_RPC_Type", ControllerServiceCapability_RPC_Type_name, ControllerServiceCapability_RPC_Type_value)
	proto.RegisterEnum("NodeServiceCapability_RPC_Type", NodeServiceCapability_RPC_Type_name, NodeServiceCapability_RPC_Type_value)
	proto.RegisterEnum("Error_GeneralError_GeneralErrorCode", Error_GeneralError_GeneralErrorCode_name, Error_GeneralError_GeneralErrorCode_value)
	proto.RegisterEnum("Error_CreateVolumeError_CreateVolumeErrorCode", Error_CreateVolumeError_CreateVolumeErrorCode_name, Error_CreateVolumeError_CreateVolumeErrorCode_value)
	proto.RegisterEnum("Error_DeleteVolumeError_DeleteVolumeErrorCode", Error_DeleteVolumeError_DeleteVolumeErrorCode_name, Error_DeleteVolumeError_DeleteVolumeErrorCode_value)
	proto.RegisterEnum("Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode", Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode_name, Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode_value)
	proto.RegisterEnum("Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode", Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode_name, Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode_value)
	proto.RegisterEnum("Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode", Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode_name, Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode_value)
	proto.RegisterEnum("Error_NodePublishVolumeError_NodePublishVolumeErrorCode", Error_NodePublishVolumeError_NodePublishVolumeErrorCode_name, Error_NodePublishVolumeError_NodePublishVolumeErrorCode_value)
	proto.RegisterEnum("Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode", Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode_name, Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode_value)
	proto.RegisterEnum("Error_ProbeNodeError_ProbeNodeErrorCode", Error_ProbeNodeError_ProbeNodeErrorCode_name, Error_ProbeNodeError_ProbeNodeErrorCode_value)
	proto.RegisterEnum("Error_GetNodeIDError_GetNodeIDErrorCode", Error_GetNodeIDError_GetNodeIDErrorCode_name, Error_GetNodeIDError_GetNodeIDErrorCode_value)
}
func (x AccessMode_Mode) String() string {
	s, ok := AccessMode_Mode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ControllerServiceCapability_RPC_Type) String() string {
	s, ok := ControllerServiceCapability_RPC_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeServiceCapability_RPC_Type) String() string {
	s, ok := NodeServiceCapability_RPC_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_GeneralError_GeneralErrorCode) String() string {
	s, ok := Error_GeneralError_GeneralErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_CreateVolumeError_CreateVolumeErrorCode) String() string {
	s, ok := Error_CreateVolumeError_CreateVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_DeleteVolumeError_DeleteVolumeErrorCode) String() string {
	s, ok := Error_DeleteVolumeError_DeleteVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode) String() string {
	s, ok := Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode) String() string {
	s, ok := Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode) String() string {
	s, ok := Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_NodePublishVolumeError_NodePublishVolumeErrorCode) String() string {
	s, ok := Error_NodePublishVolumeError_NodePublishVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode) String() string {
	s, ok := Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_ProbeNodeError_ProbeNodeErrorCode) String() string {
	s, ok := Error_ProbeNodeError_ProbeNodeErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Error_GetNodeIDError_GetNodeIDErrorCode) String() string {
	s, ok := Error_GetNodeIDError_GetNodeIDErrorCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GetSupportedVersionsRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSupportedVersionsRequest)
	if !ok {
		that2, ok := that.(GetSupportedVersionsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetSupportedVersionsResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSupportedVersionsResponse)
	if !ok {
		that2, ok := that.(GetSupportedVersionsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *GetSupportedVersionsResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSupportedVersionsResponse_Result_)
	if !ok {
		that2, ok := that.(GetSupportedVersionsResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *GetSupportedVersionsResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSupportedVersionsResponse_Error)
	if !ok {
		that2, ok := that.(GetSupportedVersionsResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *GetSupportedVersionsResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetSupportedVersionsResponse_Result)
	if !ok {
		that2, ok := that.(GetSupportedVersionsResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.SupportedVersions) != len(that1.SupportedVersions) {
		return false
	}
	for i := range this.SupportedVersions {
		if !this.SupportedVersions[i].Equal(that1.SupportedVersions[i]) {
			return false
		}
	}
	return true
}
func (this *Version) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Version)
	if !ok {
		that2, ok := that.(Version)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Major != that1.Major {
		return false
	}
	if this.Minor != that1.Minor {
		return false
	}
	if this.Patch != that1.Patch {
		return false
	}
	return true
}
func (this *GetPluginInfoRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetPluginInfoRequest)
	if !ok {
		that2, ok := that.(GetPluginInfoRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *GetPluginInfoResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetPluginInfoResponse)
	if !ok {
		that2, ok := that.(GetPluginInfoResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *GetPluginInfoResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetPluginInfoResponse_Result_)
	if !ok {
		that2, ok := that.(GetPluginInfoResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *GetPluginInfoResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetPluginInfoResponse_Error)
	if !ok {
		that2, ok := that.(GetPluginInfoResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *GetPluginInfoResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetPluginInfoResponse_Result)
	if !ok {
		that2, ok := that.(GetPluginInfoResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.VendorVersion != that1.VendorVersion {
		return false
	}
	if len(this.Manifest) != len(that1.Manifest) {
		return false
	}
	for i := range this.Manifest {
		if this.Manifest[i] != that1.Manifest[i] {
			return false
		}
	}
	return true
}
func (this *CreateVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateVolumeRequest)
	if !ok {
		that2, ok := that.(CreateVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.CapacityRange.Equal(that1.CapacityRange) {
		return false
	}
	if len(this.VolumeCapabilities) != len(that1.VolumeCapabilities) {
		return false
	}
	for i := range this.VolumeCapabilities {
		if !this.VolumeCapabilities[i].Equal(that1.VolumeCapabilities[i]) {
			return false
		}
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if this.Parameters[i] != that1.Parameters[i] {
			return false
		}
	}
	return true
}
func (this *CreateVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateVolumeResponse)
	if !ok {
		that2, ok := that.(CreateVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *CreateVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(CreateVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *CreateVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateVolumeResponse_Error)
	if !ok {
		that2, ok := that.(CreateVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *CreateVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateVolumeResponse_Result)
	if !ok {
		that2, ok := that.(CreateVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.VolumeInfo.Equal(that1.VolumeInfo) {
		return false
	}
	return true
}
func (this *VolumeCapability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeCapability)
	if !ok {
		that2, ok := that.(VolumeCapability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *VolumeCapability_Block) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeCapability_Block)
	if !ok {
		that2, ok := that.(VolumeCapability_Block)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Block.Equal(that1.Block) {
		return false
	}
	return true
}
func (this *VolumeCapability_Mount) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeCapability_Mount)
	if !ok {
		that2, ok := that.(VolumeCapability_Mount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	return true
}
func (this *VolumeCapability_BlockVolume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeCapability_BlockVolume)
	if !ok {
		that2, ok := that.(VolumeCapability_BlockVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *VolumeCapability_MountVolume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeCapability_MountVolume)
	if !ok {
		that2, ok := that.(VolumeCapability_MountVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FsType != that1.FsType {
		return false
	}
	if len(this.MountFlags) != len(that1.MountFlags) {
		return false
	}
	for i := range this.MountFlags {
		if this.MountFlags[i] != that1.MountFlags[i] {
			return false
		}
	}
	return true
}
func (this *CapacityRange) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CapacityRange)
	if !ok {
		that2, ok := that.(CapacityRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RequiredBytes != that1.RequiredBytes {
		return false
	}
	if this.LimitBytes != that1.LimitBytes {
		return false
	}
	return true
}
func (this *VolumeInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeInfo)
	if !ok {
		that2, ok := that.(VolumeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CapacityBytes != that1.CapacityBytes {
		return false
	}
	if !this.AccessMode.Equal(that1.AccessMode) {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *AccessMode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AccessMode)
	if !ok {
		that2, ok := that.(AccessMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	return true
}
func (this *VolumeID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeID)
	if !ok {
		that2, ok := that.(VolumeID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *VolumeMetadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeMetadata)
	if !ok {
		that2, ok := that.(VolumeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *DeleteVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteVolumeRequest)
	if !ok {
		that2, ok := that.(DeleteVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeId.Equal(that1.VolumeId) {
		return false
	}
	if !this.VolumeMetadata.Equal(that1.VolumeMetadata) {
		return false
	}
	return true
}
func (this *DeleteVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteVolumeResponse)
	if !ok {
		that2, ok := that.(DeleteVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *DeleteVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(DeleteVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *DeleteVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteVolumeResponse_Error)
	if !ok {
		that2, ok := that.(DeleteVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *DeleteVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteVolumeResponse_Result)
	if !ok {
		that2, ok := that.(DeleteVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ControllerPublishVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerPublishVolumeRequest)
	if !ok {
		that2, ok := that.(ControllerPublishVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeId.Equal(that1.VolumeId) {
		return false
	}
	if !this.VolumeMetadata.Equal(that1.VolumeMetadata) {
		return false
	}
	if !this.NodeId.Equal(that1.NodeId) {
		return false
	}
	if this.Readonly != that1.Readonly {
		return false
	}
	return true
}
func (this *ControllerPublishVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerPublishVolumeResponse)
	if !ok {
		that2, ok := that.(ControllerPublishVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ControllerPublishVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerPublishVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(ControllerPublishVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ControllerPublishVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerPublishVolumeResponse_Error)
	if !ok {
		that2, ok := that.(ControllerPublishVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ControllerPublishVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerPublishVolumeResponse_Result)
	if !ok {
		that2, ok := that.(ControllerPublishVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.PublishVolumeInfo.Equal(that1.PublishVolumeInfo) {
		return false
	}
	return true
}
func (this *NodeID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeID)
	if !ok {
		that2, ok := that.(NodeID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *PublishVolumeInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublishVolumeInfo)
	if !ok {
		that2, ok := that.(PublishVolumeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *ControllerUnpublishVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerUnpublishVolumeRequest)
	if !ok {
		that2, ok := that.(ControllerUnpublishVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeId.Equal(that1.VolumeId) {
		return false
	}
	if !this.VolumeMetadata.Equal(that1.VolumeMetadata) {
		return false
	}
	if !this.NodeId.Equal(that1.NodeId) {
		return false
	}
	return true
}
func (this *ControllerUnpublishVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerUnpublishVolumeResponse)
	if !ok {
		that2, ok := that.(ControllerUnpublishVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ControllerUnpublishVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerUnpublishVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(ControllerUnpublishVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ControllerUnpublishVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerUnpublishVolumeResponse_Error)
	if !ok {
		that2, ok := that.(ControllerUnpublishVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ControllerUnpublishVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerUnpublishVolumeResponse_Result)
	if !ok {
		that2, ok := that.(ControllerUnpublishVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ValidateVolumeCapabilitiesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValidateVolumeCapabilitiesRequest)
	if !ok {
		that2, ok := that.(ValidateVolumeCapabilitiesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeInfo.Equal(that1.VolumeInfo) {
		return false
	}
	if len(this.VolumeCapabilities) != len(that1.VolumeCapabilities) {
		return false
	}
	for i := range this.VolumeCapabilities {
		if !this.VolumeCapabilities[i].Equal(that1.VolumeCapabilities[i]) {
			return false
		}
	}
	return true
}
func (this *ValidateVolumeCapabilitiesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValidateVolumeCapabilitiesResponse)
	if !ok {
		that2, ok := that.(ValidateVolumeCapabilitiesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ValidateVolumeCapabilitiesResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValidateVolumeCapabilitiesResponse_Result_)
	if !ok {
		that2, ok := that.(ValidateVolumeCapabilitiesResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ValidateVolumeCapabilitiesResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValidateVolumeCapabilitiesResponse_Error)
	if !ok {
		that2, ok := that.(ValidateVolumeCapabilitiesResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ValidateVolumeCapabilitiesResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValidateVolumeCapabilitiesResponse_Result)
	if !ok {
		that2, ok := that.(ValidateVolumeCapabilitiesResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Supported != that1.Supported {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *ListVolumesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesRequest)
	if !ok {
		that2, ok := that.(ListVolumesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if this.MaxEntries != that1.MaxEntries {
		return false
	}
	if this.StartingToken != that1.StartingToken {
		return false
	}
	return true
}
func (this *ListVolumesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesResponse)
	if !ok {
		that2, ok := that.(ListVolumesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ListVolumesResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesResponse_Result_)
	if !ok {
		that2, ok := that.(ListVolumesResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ListVolumesResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesResponse_Error)
	if !ok {
		that2, ok := that.(ListVolumesResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ListVolumesResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesResponse_Result)
	if !ok {
		that2, ok := that.(ListVolumesResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Entries) != len(that1.Entries) {
		return false
	}
	for i := range this.Entries {
		if !this.Entries[i].Equal(that1.Entries[i]) {
			return false
		}
	}
	if this.NextToken != that1.NextToken {
		return false
	}
	return true
}
func (this *ListVolumesResponse_Result_Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListVolumesResponse_Result_Entry)
	if !ok {
		that2, ok := that.(ListVolumesResponse_Result_Entry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.VolumeInfo.Equal(that1.VolumeInfo) {
		return false
	}
	return true
}
func (this *GetCapacityRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetCapacityRequest)
	if !ok {
		that2, ok := that.(GetCapacityRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *GetCapacityResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetCapacityResponse)
	if !ok {
		that2, ok := that.(GetCapacityResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *GetCapacityResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetCapacityResponse_Result_)
	if !ok {
		that2, ok := that.(GetCapacityResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *GetCapacityResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetCapacityResponse_Error)
	if !ok {
		that2, ok := that.(GetCapacityResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *GetCapacityResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetCapacityResponse_Result)
	if !ok {
		that2, ok := that.(GetCapacityResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TotalCapacity != that1.TotalCapacity {
		return false
	}
	return true
}
func (this *ControllerGetCapabilitiesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerGetCapabilitiesRequest)
	if !ok {
		that2, ok := that.(ControllerGetCapabilitiesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *ControllerGetCapabilitiesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerGetCapabilitiesResponse)
	if !ok {
		that2, ok := that.(ControllerGetCapabilitiesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ControllerGetCapabilitiesResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerGetCapabilitiesResponse_Result_)
	if !ok {
		that2, ok := that.(ControllerGetCapabilitiesResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ControllerGetCapabilitiesResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerGetCapabilitiesResponse_Error)
	if !ok {
		that2, ok := that.(ControllerGetCapabilitiesResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ControllerGetCapabilitiesResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerGetCapabilitiesResponse_Result)
	if !ok {
		that2, ok := that.(ControllerGetCapabilitiesResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(that1.Capabilities[i]) {
			return false
		}
	}
	return true
}
func (this *ControllerServiceCapability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerServiceCapability)
	if !ok {
		that2, ok := that.(ControllerServiceCapability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *ControllerServiceCapability_Rpc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerServiceCapability_Rpc)
	if !ok {
		that2, ok := that.(ControllerServiceCapability_Rpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Rpc.Equal(that1.Rpc) {
		return false
	}
	return true
}
func (this *ControllerServiceCapability_VolumeCapability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerServiceCapability_VolumeCapability)
	if !ok {
		that2, ok := that.(ControllerServiceCapability_VolumeCapability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.VolumeCapability.Equal(that1.VolumeCapability) {
		return false
	}
	return true
}
func (this *ControllerServiceCapability_RPC) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ControllerServiceCapability_RPC)
	if !ok {
		that2, ok := that.(ControllerServiceCapability_RPC)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *NodePublishVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodePublishVolumeRequest)
	if !ok {
		that2, ok := that.(NodePublishVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeId.Equal(that1.VolumeId) {
		return false
	}
	if !this.VolumeMetadata.Equal(that1.VolumeMetadata) {
		return false
	}
	if !this.PublishVolumeInfo.Equal(that1.PublishVolumeInfo) {
		return false
	}
	if this.TargetPath != that1.TargetPath {
		return false
	}
	if !this.VolumeCapability.Equal(that1.VolumeCapability) {
		return false
	}
	if this.Readonly != that1.Readonly {
		return false
	}
	return true
}
func (this *NodePublishVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodePublishVolumeResponse)
	if !ok {
		that2, ok := that.(NodePublishVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *NodePublishVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodePublishVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(NodePublishVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *NodePublishVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodePublishVolumeResponse_Error)
	if !ok {
		that2, ok := that.(NodePublishVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *NodePublishVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodePublishVolumeResponse_Result)
	if !ok {
		that2, ok := that.(NodePublishVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *NodeUnpublishVolumeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeUnpublishVolumeRequest)
	if !ok {
		that2, ok := that.(NodeUnpublishVolumeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	if !this.VolumeId.Equal(that1.VolumeId) {
		return false
	}
	if !this.VolumeMetadata.Equal(that1.VolumeMetadata) {
		return false
	}
	if this.TargetPath != that1.TargetPath {
		return false
	}
	return true
}
func (this *NodeUnpublishVolumeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeUnpublishVolumeResponse)
	if !ok {
		that2, ok := that.(NodeUnpublishVolumeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *NodeUnpublishVolumeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeUnpublishVolumeResponse_Result_)
	if !ok {
		that2, ok := that.(NodeUnpublishVolumeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *NodeUnpublishVolumeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeUnpublishVolumeResponse_Error)
	if !ok {
		that2, ok := that.(NodeUnpublishVolumeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *NodeUnpublishVolumeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeUnpublishVolumeResponse_Result)
	if !ok {
		that2, ok := that.(NodeUnpublishVolumeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetNodeIDRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetNodeIDRequest)
	if !ok {
		that2, ok := that.(GetNodeIDRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *GetNodeIDResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetNodeIDResponse)
	if !ok {
		that2, ok := that.(GetNodeIDResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *GetNodeIDResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetNodeIDResponse_Result_)
	if !ok {
		that2, ok := that.(GetNodeIDResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *GetNodeIDResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetNodeIDResponse_Error)
	if !ok {
		that2, ok := that.(GetNodeIDResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *GetNodeIDResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetNodeIDResponse_Result)
	if !ok {
		that2, ok := that.(GetNodeIDResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NodeId.Equal(that1.NodeId) {
		return false
	}
	return true
}
func (this *ProbeNodeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProbeNodeRequest)
	if !ok {
		that2, ok := that.(ProbeNodeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *ProbeNodeResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProbeNodeResponse)
	if !ok {
		that2, ok := that.(ProbeNodeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *ProbeNodeResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProbeNodeResponse_Result_)
	if !ok {
		that2, ok := that.(ProbeNodeResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *ProbeNodeResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProbeNodeResponse_Error)
	if !ok {
		that2, ok := that.(ProbeNodeResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *ProbeNodeResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProbeNodeResponse_Result)
	if !ok {
		that2, ok := that.(ProbeNodeResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *NodeGetCapabilitiesRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeGetCapabilitiesRequest)
	if !ok {
		that2, ok := that.(NodeGetCapabilitiesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Version.Equal(that1.Version) {
		return false
	}
	return true
}
func (this *NodeGetCapabilitiesResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeGetCapabilitiesResponse)
	if !ok {
		that2, ok := that.(NodeGetCapabilitiesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *NodeGetCapabilitiesResponse_Result_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeGetCapabilitiesResponse_Result_)
	if !ok {
		that2, ok := that.(NodeGetCapabilitiesResponse_Result_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *NodeGetCapabilitiesResponse_Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeGetCapabilitiesResponse_Error)
	if !ok {
		that2, ok := that.(NodeGetCapabilitiesResponse_Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *NodeGetCapabilitiesResponse_Result) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeGetCapabilitiesResponse_Result)
	if !ok {
		that2, ok := that.(NodeGetCapabilitiesResponse_Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(that1.Capabilities[i]) {
			return false
		}
	}
	return true
}
func (this *NodeServiceCapability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeServiceCapability)
	if !ok {
		that2, ok := that.(NodeServiceCapability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *NodeServiceCapability_Rpc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeServiceCapability_Rpc)
	if !ok {
		that2, ok := that.(NodeServiceCapability_Rpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Rpc.Equal(that1.Rpc) {
		return false
	}
	return true
}
func (this *NodeServiceCapability_VolumeCapability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeServiceCapability_VolumeCapability)
	if !ok {
		that2, ok := that.(NodeServiceCapability_VolumeCapability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.VolumeCapability.Equal(that1.VolumeCapability) {
		return false
	}
	return true
}
func (this *NodeServiceCapability_RPC) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NodeServiceCapability_RPC)
	if !ok {
		that2, ok := that.(NodeServiceCapability_RPC)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Error) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error)
	if !ok {
		that2, ok := that.(Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Error_GeneralError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_GeneralError_)
	if !ok {
		that2, ok := that.(Error_GeneralError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.GeneralError.Equal(that1.GeneralError) {
		return false
	}
	return true
}
func (this *Error_CreateVolumeError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_CreateVolumeError_)
	if !ok {
		that2, ok := that.(Error_CreateVolumeError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CreateVolumeError.Equal(that1.CreateVolumeError) {
		return false
	}
	return true
}
func (this *Error_DeleteVolumeError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_DeleteVolumeError_)
	if !ok {
		that2, ok := that.(Error_DeleteVolumeError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DeleteVolumeError.Equal(that1.DeleteVolumeError) {
		return false
	}
	return true
}
func (this *Error_ControllerPublishVolumeVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ControllerPublishVolumeVolumeError)
	if !ok {
		that2, ok := that.(Error_ControllerPublishVolumeVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ControllerPublishVolumeVolumeError.Equal(that1.ControllerPublishVolumeVolumeError) {
		return false
	}
	return true
}
func (this *Error_ControllerUnpublishVolumeVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ControllerUnpublishVolumeVolumeError)
	if !ok {
		that2, ok := that.(Error_ControllerUnpublishVolumeVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ControllerUnpublishVolumeVolumeError.Equal(that1.ControllerUnpublishVolumeVolumeError) {
		return false
	}
	return true
}
func (this *Error_ValidateVolumeCapabilitiesError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ValidateVolumeCapabilitiesError_)
	if !ok {
		that2, ok := that.(Error_ValidateVolumeCapabilitiesError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ValidateVolumeCapabilitiesError.Equal(that1.ValidateVolumeCapabilitiesError) {
		return false
	}
	return true
}
func (this *Error_NodePublishVolumeError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_NodePublishVolumeError_)
	if !ok {
		that2, ok := that.(Error_NodePublishVolumeError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NodePublishVolumeError.Equal(that1.NodePublishVolumeError) {
		return false
	}
	return true
}
func (this *Error_NodeUnpublishVolumeError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_NodeUnpublishVolumeError_)
	if !ok {
		that2, ok := that.(Error_NodeUnpublishVolumeError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NodeUnpublishVolumeError.Equal(that1.NodeUnpublishVolumeError) {
		return false
	}
	return true
}
func (this *Error_ProbeNodeError_) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ProbeNodeError_)
	if !ok {
		that2, ok := that.(Error_ProbeNodeError_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ProbeNodeError.Equal(that1.ProbeNodeError) {
		return false
	}
	return true
}
func (this *Error_GeneralError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_GeneralError)
	if !ok {
		that2, ok := that.(Error_GeneralError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.CallerMustNotRetry != that1.CallerMustNotRetry {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_CreateVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_CreateVolumeError)
	if !ok {
		that2, ok := that.(Error_CreateVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_DeleteVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_DeleteVolumeError)
	if !ok {
		that2, ok := that.(Error_DeleteVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_ControllerPublishVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ControllerPublishVolumeError)
	if !ok {
		that2, ok := that.(Error_ControllerPublishVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	if len(this.NodeIds) != len(that1.NodeIds) {
		return false
	}
	for i := range this.NodeIds {
		if !this.NodeIds[i].Equal(that1.NodeIds[i]) {
			return false
		}
	}
	return true
}
func (this *Error_ControllerUnpublishVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ControllerUnpublishVolumeError)
	if !ok {
		that2, ok := that.(Error_ControllerUnpublishVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_ValidateVolumeCapabilitiesError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ValidateVolumeCapabilitiesError)
	if !ok {
		that2, ok := that.(Error_ValidateVolumeCapabilitiesError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_NodePublishVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_NodePublishVolumeError)
	if !ok {
		that2, ok := that.(Error_NodePublishVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_NodeUnpublishVolumeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_NodeUnpublishVolumeError)
	if !ok {
		that2, ok := that.(Error_NodeUnpublishVolumeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_ProbeNodeError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_ProbeNodeError)
	if !ok {
		that2, ok := that.(Error_ProbeNodeError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *Error_GetNodeIDError) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Error_GetNodeIDError)
	if !ok {
		that2, ok := that.(Error_GetNodeIDError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorDescription != that1.ErrorDescription {
		return false
	}
	return true
}
func (this *GetSupportedVersionsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.GetSupportedVersionsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSupportedVersionsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.GetSupportedVersionsResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSupportedVersionsResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetSupportedVersionsResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *GetSupportedVersionsResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetSupportedVersionsResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *GetSupportedVersionsResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetSupportedVersionsResponse_Result{")
	if this.SupportedVersions != nil {
		s = append(s, "SupportedVersions: "+fmt.Sprintf("%#v", this.SupportedVersions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Version) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.Version{")
	s = append(s, "Major: "+fmt.Sprintf("%#v", this.Major)+",\n")
	s = append(s, "Minor: "+fmt.Sprintf("%#v", this.Minor)+",\n")
	s = append(s, "Patch: "+fmt.Sprintf("%#v", this.Patch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPluginInfoRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetPluginInfoRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPluginInfoResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.GetPluginInfoResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetPluginInfoResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetPluginInfoResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *GetPluginInfoResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetPluginInfoResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *GetPluginInfoResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.GetPluginInfoResponse_Result{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "VendorVersion: "+fmt.Sprintf("%#v", this.VendorVersion)+",\n")
	keysForManifest := make([]string, 0, len(this.Manifest))
	for k, _ := range this.Manifest {
		keysForManifest = append(keysForManifest, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForManifest)
	mapStringForManifest := "map[string]string{"
	for _, k := range keysForManifest {
		mapStringForManifest += fmt.Sprintf("%#v: %#v,", k, this.Manifest[k])
	}
	mapStringForManifest += "}"
	if this.Manifest != nil {
		s = append(s, "Manifest: "+mapStringForManifest+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&csilvm.CreateVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.CapacityRange != nil {
		s = append(s, "CapacityRange: "+fmt.Sprintf("%#v", this.CapacityRange)+",\n")
	}
	if this.VolumeCapabilities != nil {
		s = append(s, "VolumeCapabilities: "+fmt.Sprintf("%#v", this.VolumeCapabilities)+",\n")
	}
	keysForParameters := make([]string, 0, len(this.Parameters))
	for k, _ := range this.Parameters {
		keysForParameters = append(keysForParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForParameters)
	mapStringForParameters := "map[string]string{"
	for _, k := range keysForParameters {
		mapStringForParameters += fmt.Sprintf("%#v: %#v,", k, this.Parameters[k])
	}
	mapStringForParameters += "}"
	if this.Parameters != nil {
		s = append(s, "Parameters: "+mapStringForParameters+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.CreateVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.CreateVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *CreateVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.CreateVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *CreateVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.CreateVolumeResponse_Result{")
	if this.VolumeInfo != nil {
		s = append(s, "VolumeInfo: "+fmt.Sprintf("%#v", this.VolumeInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeCapability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.VolumeCapability{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeCapability_Block) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.VolumeCapability_Block{` +
		`Block:` + fmt.Sprintf("%#v", this.Block) + `}`}, ", ")
	return s
}
func (this *VolumeCapability_Mount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.VolumeCapability_Mount{` +
		`Mount:` + fmt.Sprintf("%#v", this.Mount) + `}`}, ", ")
	return s
}
func (this *VolumeCapability_BlockVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.VolumeCapability_BlockVolume{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeCapability_MountVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.VolumeCapability_MountVolume{")
	s = append(s, "FsType: "+fmt.Sprintf("%#v", this.FsType)+",\n")
	s = append(s, "MountFlags: "+fmt.Sprintf("%#v", this.MountFlags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CapacityRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.CapacityRange{")
	s = append(s, "RequiredBytes: "+fmt.Sprintf("%#v", this.RequiredBytes)+",\n")
	s = append(s, "LimitBytes: "+fmt.Sprintf("%#v", this.LimitBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&csilvm.VolumeInfo{")
	s = append(s, "CapacityBytes: "+fmt.Sprintf("%#v", this.CapacityBytes)+",\n")
	if this.AccessMode != nil {
		s = append(s, "AccessMode: "+fmt.Sprintf("%#v", this.AccessMode)+",\n")
	}
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccessMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.AccessMode{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.VolumeID{")
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%#v: %#v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	if this.Values != nil {
		s = append(s, "Values: "+mapStringForValues+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.VolumeMetadata{")
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%#v: %#v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	if this.Values != nil {
		s = append(s, "Values: "+mapStringForValues+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.DeleteVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeId != nil {
		s = append(s, "VolumeId: "+fmt.Sprintf("%#v", this.VolumeId)+",\n")
	}
	if this.VolumeMetadata != nil {
		s = append(s, "VolumeMetadata: "+fmt.Sprintf("%#v", this.VolumeMetadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.DeleteVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.DeleteVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *DeleteVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.DeleteVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *DeleteVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.DeleteVolumeResponse_Result{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerPublishVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&csilvm.ControllerPublishVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeId != nil {
		s = append(s, "VolumeId: "+fmt.Sprintf("%#v", this.VolumeId)+",\n")
	}
	if this.VolumeMetadata != nil {
		s = append(s, "VolumeMetadata: "+fmt.Sprintf("%#v", this.VolumeMetadata)+",\n")
	}
	if this.NodeId != nil {
		s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	}
	s = append(s, "Readonly: "+fmt.Sprintf("%#v", this.Readonly)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerPublishVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ControllerPublishVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerPublishVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerPublishVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ControllerPublishVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerPublishVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ControllerPublishVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ControllerPublishVolumeResponse_Result{")
	if this.PublishVolumeInfo != nil {
		s = append(s, "PublishVolumeInfo: "+fmt.Sprintf("%#v", this.PublishVolumeInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.NodeID{")
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%#v: %#v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	if this.Values != nil {
		s = append(s, "Values: "+mapStringForValues+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PublishVolumeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.PublishVolumeInfo{")
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%#v: %#v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	if this.Values != nil {
		s = append(s, "Values: "+mapStringForValues+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerUnpublishVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&csilvm.ControllerUnpublishVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeId != nil {
		s = append(s, "VolumeId: "+fmt.Sprintf("%#v", this.VolumeId)+",\n")
	}
	if this.VolumeMetadata != nil {
		s = append(s, "VolumeMetadata: "+fmt.Sprintf("%#v", this.VolumeMetadata)+",\n")
	}
	if this.NodeId != nil {
		s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerUnpublishVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ControllerUnpublishVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerUnpublishVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerUnpublishVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ControllerUnpublishVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerUnpublishVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ControllerUnpublishVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.ControllerUnpublishVolumeResponse_Result{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidateVolumeCapabilitiesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.ValidateVolumeCapabilitiesRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeInfo != nil {
		s = append(s, "VolumeInfo: "+fmt.Sprintf("%#v", this.VolumeInfo)+",\n")
	}
	if this.VolumeCapabilities != nil {
		s = append(s, "VolumeCapabilities: "+fmt.Sprintf("%#v", this.VolumeCapabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidateVolumeCapabilitiesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ValidateVolumeCapabilitiesResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidateVolumeCapabilitiesResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ValidateVolumeCapabilitiesResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ValidateVolumeCapabilitiesResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ValidateVolumeCapabilitiesResponse_Result{")
	s = append(s, "Supported: "+fmt.Sprintf("%#v", this.Supported)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListVolumesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.ListVolumesRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "MaxEntries: "+fmt.Sprintf("%#v", this.MaxEntries)+",\n")
	s = append(s, "StartingToken: "+fmt.Sprintf("%#v", this.StartingToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListVolumesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ListVolumesResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListVolumesResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ListVolumesResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ListVolumesResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ListVolumesResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ListVolumesResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ListVolumesResponse_Result{")
	if this.Entries != nil {
		s = append(s, "Entries: "+fmt.Sprintf("%#v", this.Entries)+",\n")
	}
	s = append(s, "NextToken: "+fmt.Sprintf("%#v", this.NextToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListVolumesResponse_Result_Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ListVolumesResponse_Result_Entry{")
	if this.VolumeInfo != nil {
		s = append(s, "VolumeInfo: "+fmt.Sprintf("%#v", this.VolumeInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCapacityRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetCapacityRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCapacityResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.GetCapacityResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetCapacityResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetCapacityResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *GetCapacityResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetCapacityResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *GetCapacityResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetCapacityResponse_Result{")
	s = append(s, "TotalCapacity: "+fmt.Sprintf("%#v", this.TotalCapacity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerGetCapabilitiesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ControllerGetCapabilitiesRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerGetCapabilitiesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ControllerGetCapabilitiesResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerGetCapabilitiesResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerGetCapabilitiesResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ControllerGetCapabilitiesResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerGetCapabilitiesResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ControllerGetCapabilitiesResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ControllerGetCapabilitiesResponse_Result{")
	if this.Capabilities != nil {
		s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerServiceCapability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ControllerServiceCapability{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ControllerServiceCapability_Rpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerServiceCapability_Rpc{` +
		`Rpc:` + fmt.Sprintf("%#v", this.Rpc) + `}`}, ", ")
	return s
}
func (this *ControllerServiceCapability_VolumeCapability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ControllerServiceCapability_VolumeCapability{` +
		`VolumeCapability:` + fmt.Sprintf("%#v", this.VolumeCapability) + `}`}, ", ")
	return s
}
func (this *ControllerServiceCapability_RPC) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ControllerServiceCapability_RPC{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodePublishVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&csilvm.NodePublishVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeId != nil {
		s = append(s, "VolumeId: "+fmt.Sprintf("%#v", this.VolumeId)+",\n")
	}
	if this.VolumeMetadata != nil {
		s = append(s, "VolumeMetadata: "+fmt.Sprintf("%#v", this.VolumeMetadata)+",\n")
	}
	if this.PublishVolumeInfo != nil {
		s = append(s, "PublishVolumeInfo: "+fmt.Sprintf("%#v", this.PublishVolumeInfo)+",\n")
	}
	s = append(s, "TargetPath: "+fmt.Sprintf("%#v", this.TargetPath)+",\n")
	if this.VolumeCapability != nil {
		s = append(s, "VolumeCapability: "+fmt.Sprintf("%#v", this.VolumeCapability)+",\n")
	}
	s = append(s, "Readonly: "+fmt.Sprintf("%#v", this.Readonly)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodePublishVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.NodePublishVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodePublishVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodePublishVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *NodePublishVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodePublishVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *NodePublishVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.NodePublishVolumeResponse_Result{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeUnpublishVolumeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&csilvm.NodeUnpublishVolumeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.VolumeId != nil {
		s = append(s, "VolumeId: "+fmt.Sprintf("%#v", this.VolumeId)+",\n")
	}
	if this.VolumeMetadata != nil {
		s = append(s, "VolumeMetadata: "+fmt.Sprintf("%#v", this.VolumeMetadata)+",\n")
	}
	s = append(s, "TargetPath: "+fmt.Sprintf("%#v", this.TargetPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeUnpublishVolumeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.NodeUnpublishVolumeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeUnpublishVolumeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeUnpublishVolumeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *NodeUnpublishVolumeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeUnpublishVolumeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *NodeUnpublishVolumeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.NodeUnpublishVolumeResponse_Result{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNodeIDRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetNodeIDRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNodeIDResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.GetNodeIDResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetNodeIDResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetNodeIDResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *GetNodeIDResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.GetNodeIDResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *GetNodeIDResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.GetNodeIDResponse_Result{")
	if this.NodeId != nil {
		s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeNodeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.ProbeNodeRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeNodeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.ProbeNodeResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeNodeResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ProbeNodeResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *ProbeNodeResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.ProbeNodeResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *ProbeNodeResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&csilvm.ProbeNodeResponse_Result{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeGetCapabilitiesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.NodeGetCapabilitiesRequest{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeGetCapabilitiesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.NodeGetCapabilitiesResponse{")
	if this.Reply != nil {
		s = append(s, "Reply: "+fmt.Sprintf("%#v", this.Reply)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeGetCapabilitiesResponse_Result_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeGetCapabilitiesResponse_Result_{` +
		`Result:` + fmt.Sprintf("%#v", this.Result) + `}`}, ", ")
	return s
}
func (this *NodeGetCapabilitiesResponse_Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeGetCapabilitiesResponse_Error{` +
		`Error:` + fmt.Sprintf("%#v", this.Error) + `}`}, ", ")
	return s
}
func (this *NodeGetCapabilitiesResponse_Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.NodeGetCapabilitiesResponse_Result{")
	if this.Capabilities != nil {
		s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeServiceCapability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.NodeServiceCapability{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeServiceCapability_Rpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeServiceCapability_Rpc{` +
		`Rpc:` + fmt.Sprintf("%#v", this.Rpc) + `}`}, ", ")
	return s
}
func (this *NodeServiceCapability_VolumeCapability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.NodeServiceCapability_VolumeCapability{` +
		`VolumeCapability:` + fmt.Sprintf("%#v", this.VolumeCapability) + `}`}, ", ")
	return s
}
func (this *NodeServiceCapability_RPC) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&csilvm.NodeServiceCapability_RPC{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&csilvm.Error{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_GeneralError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_GeneralError_{` +
		`GeneralError:` + fmt.Sprintf("%#v", this.GeneralError) + `}`}, ", ")
	return s
}
func (this *Error_CreateVolumeError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_CreateVolumeError_{` +
		`CreateVolumeError:` + fmt.Sprintf("%#v", this.CreateVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_DeleteVolumeError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_DeleteVolumeError_{` +
		`DeleteVolumeError:` + fmt.Sprintf("%#v", this.DeleteVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_ControllerPublishVolumeVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_ControllerPublishVolumeVolumeError{` +
		`ControllerPublishVolumeVolumeError:` + fmt.Sprintf("%#v", this.ControllerPublishVolumeVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_ControllerUnpublishVolumeVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_ControllerUnpublishVolumeVolumeError{` +
		`ControllerUnpublishVolumeVolumeError:` + fmt.Sprintf("%#v", this.ControllerUnpublishVolumeVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_ValidateVolumeCapabilitiesError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_ValidateVolumeCapabilitiesError_{` +
		`ValidateVolumeCapabilitiesError:` + fmt.Sprintf("%#v", this.ValidateVolumeCapabilitiesError) + `}`}, ", ")
	return s
}
func (this *Error_NodePublishVolumeError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_NodePublishVolumeError_{` +
		`NodePublishVolumeError:` + fmt.Sprintf("%#v", this.NodePublishVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_NodeUnpublishVolumeError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_NodeUnpublishVolumeError_{` +
		`NodeUnpublishVolumeError:` + fmt.Sprintf("%#v", this.NodeUnpublishVolumeError) + `}`}, ", ")
	return s
}
func (this *Error_ProbeNodeError_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&csilvm.Error_ProbeNodeError_{` +
		`ProbeNodeError:` + fmt.Sprintf("%#v", this.ProbeNodeError) + `}`}, ", ")
	return s
}
func (this *Error_GeneralError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.Error_GeneralError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "CallerMustNotRetry: "+fmt.Sprintf("%#v", this.CallerMustNotRetry)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_CreateVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_CreateVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_DeleteVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_DeleteVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_ControllerPublishVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&csilvm.Error_ControllerPublishVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	if this.NodeIds != nil {
		s = append(s, "NodeIds: "+fmt.Sprintf("%#v", this.NodeIds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_ControllerUnpublishVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_ControllerUnpublishVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_ValidateVolumeCapabilitiesError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_ValidateVolumeCapabilitiesError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_NodePublishVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_NodePublishVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_NodeUnpublishVolumeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_NodeUnpublishVolumeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_ProbeNodeError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_ProbeNodeError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error_GetNodeIDError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&csilvm.Error_GetNodeIDError{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorDescription: "+fmt.Sprintf("%#v", this.ErrorDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCsi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Identity service

type IdentityClient interface {
	GetSupportedVersions(ctx context.Context, in *GetSupportedVersionsRequest, opts ...grpc.CallOption) (*GetSupportedVersionsResponse, error)
	GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error)
}

type identityClient struct {
	cc *grpc.ClientConn
}

func NewIdentityClient(cc *grpc.ClientConn) IdentityClient {
	return &identityClient{cc}
}

func (c *identityClient) GetSupportedVersions(ctx context.Context, in *GetSupportedVersionsRequest, opts ...grpc.CallOption) (*GetSupportedVersionsResponse, error) {
	out := new(GetSupportedVersionsResponse)
	err := grpc.Invoke(ctx, "/Identity/GetSupportedVersions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityClient) GetPluginInfo(ctx context.Context, in *GetPluginInfoRequest, opts ...grpc.CallOption) (*GetPluginInfoResponse, error) {
	out := new(GetPluginInfoResponse)
	err := grpc.Invoke(ctx, "/Identity/GetPluginInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Identity service

type IdentityServer interface {
	GetSupportedVersions(context.Context, *GetSupportedVersionsRequest) (*GetSupportedVersionsResponse, error)
	GetPluginInfo(context.Context, *GetPluginInfoRequest) (*GetPluginInfoResponse, error)
}

func RegisterIdentityServer(s *grpc.Server, srv IdentityServer) {
	s.RegisterService(&_Identity_serviceDesc, srv)
}

func _Identity_GetSupportedVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSupportedVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).GetSupportedVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Identity/GetSupportedVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).GetSupportedVersions(ctx, req.(*GetSupportedVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Identity_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Identity/GetPluginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityServer).GetPluginInfo(ctx, req.(*GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Identity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Identity",
	HandlerType: (*IdentityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSupportedVersions",
			Handler:    _Identity_GetSupportedVersions_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _Identity_GetPluginInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "csi.proto",
}

// Client API for Controller service

type ControllerClient interface {
	CreateVolume(ctx context.Context, in *CreateVolumeRequest, opts ...grpc.CallOption) (*CreateVolumeResponse, error)
	DeleteVolume(ctx context.Context, in *DeleteVolumeRequest, opts ...grpc.CallOption) (*DeleteVolumeResponse, error)
	ControllerPublishVolume(ctx context.Context, in *ControllerPublishVolumeRequest, opts ...grpc.CallOption) (*ControllerPublishVolumeResponse, error)
	ControllerUnpublishVolume(ctx context.Context, in *ControllerUnpublishVolumeRequest, opts ...grpc.CallOption) (*ControllerUnpublishVolumeResponse, error)
	ValidateVolumeCapabilities(ctx context.Context, in *ValidateVolumeCapabilitiesRequest, opts ...grpc.CallOption) (*ValidateVolumeCapabilitiesResponse, error)
	ListVolumes(ctx context.Context, in *ListVolumesRequest, opts ...grpc.CallOption) (*ListVolumesResponse, error)
	GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error)
	ControllerGetCapabilities(ctx context.Context, in *ControllerGetCapabilitiesRequest, opts ...grpc.CallOption) (*ControllerGetCapabilitiesResponse, error)
}

type controllerClient struct {
	cc *grpc.ClientConn
}

func NewControllerClient(cc *grpc.ClientConn) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) CreateVolume(ctx context.Context, in *CreateVolumeRequest, opts ...grpc.CallOption) (*CreateVolumeResponse, error) {
	out := new(CreateVolumeResponse)
	err := grpc.Invoke(ctx, "/Controller/CreateVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteVolume(ctx context.Context, in *DeleteVolumeRequest, opts ...grpc.CallOption) (*DeleteVolumeResponse, error) {
	out := new(DeleteVolumeResponse)
	err := grpc.Invoke(ctx, "/Controller/DeleteVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ControllerPublishVolume(ctx context.Context, in *ControllerPublishVolumeRequest, opts ...grpc.CallOption) (*ControllerPublishVolumeResponse, error) {
	out := new(ControllerPublishVolumeResponse)
	err := grpc.Invoke(ctx, "/Controller/ControllerPublishVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ControllerUnpublishVolume(ctx context.Context, in *ControllerUnpublishVolumeRequest, opts ...grpc.CallOption) (*ControllerUnpublishVolumeResponse, error) {
	out := new(ControllerUnpublishVolumeResponse)
	err := grpc.Invoke(ctx, "/Controller/ControllerUnpublishVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ValidateVolumeCapabilities(ctx context.Context, in *ValidateVolumeCapabilitiesRequest, opts ...grpc.CallOption) (*ValidateVolumeCapabilitiesResponse, error) {
	out := new(ValidateVolumeCapabilitiesResponse)
	err := grpc.Invoke(ctx, "/Controller/ValidateVolumeCapabilities", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ListVolumes(ctx context.Context, in *ListVolumesRequest, opts ...grpc.CallOption) (*ListVolumesResponse, error) {
	out := new(ListVolumesResponse)
	err := grpc.Invoke(ctx, "/Controller/ListVolumes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error) {
	out := new(GetCapacityResponse)
	err := grpc.Invoke(ctx, "/Controller/GetCapacity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ControllerGetCapabilities(ctx context.Context, in *ControllerGetCapabilitiesRequest, opts ...grpc.CallOption) (*ControllerGetCapabilitiesResponse, error) {
	out := new(ControllerGetCapabilitiesResponse)
	err := grpc.Invoke(ctx, "/Controller/ControllerGetCapabilities", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Controller service

type ControllerServer interface {
	CreateVolume(context.Context, *CreateVolumeRequest) (*CreateVolumeResponse, error)
	DeleteVolume(context.Context, *DeleteVolumeRequest) (*DeleteVolumeResponse, error)
	ControllerPublishVolume(context.Context, *ControllerPublishVolumeRequest) (*ControllerPublishVolumeResponse, error)
	ControllerUnpublishVolume(context.Context, *ControllerUnpublishVolumeRequest) (*ControllerUnpublishVolumeResponse, error)
	ValidateVolumeCapabilities(context.Context, *ValidateVolumeCapabilitiesRequest) (*ValidateVolumeCapabilitiesResponse, error)
	ListVolumes(context.Context, *ListVolumesRequest) (*ListVolumesResponse, error)
	GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error)
	ControllerGetCapabilities(context.Context, *ControllerGetCapabilitiesRequest) (*ControllerGetCapabilitiesResponse, error)
}

func RegisterControllerServer(s *grpc.Server, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/CreateVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateVolume(ctx, req.(*CreateVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/DeleteVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteVolume(ctx, req.(*DeleteVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ControllerPublishVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControllerPublishVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ControllerPublishVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/ControllerPublishVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ControllerPublishVolume(ctx, req.(*ControllerPublishVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ControllerUnpublishVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControllerUnpublishVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ControllerUnpublishVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/ControllerUnpublishVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ControllerUnpublishVolume(ctx, req.(*ControllerUnpublishVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ValidateVolumeCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateVolumeCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ValidateVolumeCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/ValidateVolumeCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ValidateVolumeCapabilities(ctx, req.(*ValidateVolumeCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ListVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVolumesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ListVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/ListVolumes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ListVolumes(ctx, req.(*ListVolumesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_GetCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).GetCapacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/GetCapacity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).GetCapacity(ctx, req.(*GetCapacityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ControllerGetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControllerGetCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ControllerGetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Controller/ControllerGetCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ControllerGetCapabilities(ctx, req.(*ControllerGetCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _Controller_CreateVolume_Handler,
		},
		{
			MethodName: "DeleteVolume",
			Handler:    _Controller_DeleteVolume_Handler,
		},
		{
			MethodName: "ControllerPublishVolume",
			Handler:    _Controller_ControllerPublishVolume_Handler,
		},
		{
			MethodName: "ControllerUnpublishVolume",
			Handler:    _Controller_ControllerUnpublishVolume_Handler,
		},
		{
			MethodName: "ValidateVolumeCapabilities",
			Handler:    _Controller_ValidateVolumeCapabilities_Handler,
		},
		{
			MethodName: "ListVolumes",
			Handler:    _Controller_ListVolumes_Handler,
		},
		{
			MethodName: "GetCapacity",
			Handler:    _Controller_GetCapacity_Handler,
		},
		{
			MethodName: "ControllerGetCapabilities",
			Handler:    _Controller_ControllerGetCapabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "csi.proto",
}

// Client API for Node service

type NodeClient interface {
	NodePublishVolume(ctx context.Context, in *NodePublishVolumeRequest, opts ...grpc.CallOption) (*NodePublishVolumeResponse, error)
	NodeUnpublishVolume(ctx context.Context, in *NodeUnpublishVolumeRequest, opts ...grpc.CallOption) (*NodeUnpublishVolumeResponse, error)
	GetNodeID(ctx context.Context, in *GetNodeIDRequest, opts ...grpc.CallOption) (*GetNodeIDResponse, error)
	ProbeNode(ctx context.Context, in *ProbeNodeRequest, opts ...grpc.CallOption) (*ProbeNodeResponse, error)
	NodeGetCapabilities(ctx context.Context, in *NodeGetCapabilitiesRequest, opts ...grpc.CallOption) (*NodeGetCapabilitiesResponse, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) NodePublishVolume(ctx context.Context, in *NodePublishVolumeRequest, opts ...grpc.CallOption) (*NodePublishVolumeResponse, error) {
	out := new(NodePublishVolumeResponse)
	err := grpc.Invoke(ctx, "/Node/NodePublishVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) NodeUnpublishVolume(ctx context.Context, in *NodeUnpublishVolumeRequest, opts ...grpc.CallOption) (*NodeUnpublishVolumeResponse, error) {
	out := new(NodeUnpublishVolumeResponse)
	err := grpc.Invoke(ctx, "/Node/NodeUnpublishVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNodeID(ctx context.Context, in *GetNodeIDRequest, opts ...grpc.CallOption) (*GetNodeIDResponse, error) {
	out := new(GetNodeIDResponse)
	err := grpc.Invoke(ctx, "/Node/GetNodeID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ProbeNode(ctx context.Context, in *ProbeNodeRequest, opts ...grpc.CallOption) (*ProbeNodeResponse, error) {
	out := new(ProbeNodeResponse)
	err := grpc.Invoke(ctx, "/Node/ProbeNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) NodeGetCapabilities(ctx context.Context, in *NodeGetCapabilitiesRequest, opts ...grpc.CallOption) (*NodeGetCapabilitiesResponse, error) {
	out := new(NodeGetCapabilitiesResponse)
	err := grpc.Invoke(ctx, "/Node/NodeGetCapabilities", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Node service

type NodeServer interface {
	NodePublishVolume(context.Context, *NodePublishVolumeRequest) (*NodePublishVolumeResponse, error)
	NodeUnpublishVolume(context.Context, *NodeUnpublishVolumeRequest) (*NodeUnpublishVolumeResponse, error)
	GetNodeID(context.Context, *GetNodeIDRequest) (*GetNodeIDResponse, error)
	ProbeNode(context.Context, *ProbeNodeRequest) (*ProbeNodeResponse, error)
	NodeGetCapabilities(context.Context, *NodeGetCapabilitiesRequest) (*NodeGetCapabilitiesResponse, error)
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_NodePublishVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodePublishVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).NodePublishVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Node/NodePublishVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).NodePublishVolume(ctx, req.(*NodePublishVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_NodeUnpublishVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeUnpublishVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).NodeUnpublishVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Node/NodeUnpublishVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).NodeUnpublishVolume(ctx, req.(*NodeUnpublishVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNodeID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNodeID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Node/GetNodeID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNodeID(ctx, req.(*GetNodeIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ProbeNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbeNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ProbeNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Node/ProbeNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ProbeNode(ctx, req.(*ProbeNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_NodeGetCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGetCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).NodeGetCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Node/NodeGetCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).NodeGetCapabilities(ctx, req.(*NodeGetCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NodePublishVolume",
			Handler:    _Node_NodePublishVolume_Handler,
		},
		{
			MethodName: "NodeUnpublishVolume",
			Handler:    _Node_NodeUnpublishVolume_Handler,
		},
		{
			MethodName: "GetNodeID",
			Handler:    _Node_GetNodeID_Handler,
		},
		{
			MethodName: "ProbeNode",
			Handler:    _Node_ProbeNode_Handler,
		},
		{
			MethodName: "NodeGetCapabilities",
			Handler:    _Node_NodeGetCapabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "csi.proto",
}

func (m *GetSupportedVersionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSupportedVersionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetSupportedVersionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSupportedVersionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn1, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *GetSupportedVersionsResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n2, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *GetSupportedVersionsResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n3, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *GetSupportedVersionsResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSupportedVersionsResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SupportedVersions) > 0 {
		for _, msg := range m.SupportedVersions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Minor))
	}
	if m.Patch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Patch))
	}
	return i, nil
}

func (m *GetPluginInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPluginInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n4, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GetPluginInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPluginInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn5, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *GetPluginInfoResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n6, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *GetPluginInfoResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n7, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *GetPluginInfoResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPluginInfoResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.VendorVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.VendorVersion)))
		i += copy(dAtA[i:], m.VendorVersion)
	}
	if len(m.Manifest) > 0 {
		for k, _ := range m.Manifest {
			dAtA[i] = 0x1a
			i++
			v := m.Manifest[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *CreateVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n8, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.CapacityRange != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.CapacityRange.Size()))
		n9, err := m.CapacityRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.VolumeCapabilities) > 0 {
		for _, msg := range m.VolumeCapabilities {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Parameters) > 0 {
		for k, _ := range m.Parameters {
			dAtA[i] = 0x2a
			i++
			v := m.Parameters[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *CreateVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn10, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *CreateVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n11, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *CreateVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n12, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *CreateVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeInfo.Size()))
		n13, err := m.VolumeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *VolumeCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeCapability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn14, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *VolumeCapability_Block) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Block != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Block.Size()))
		n15, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *VolumeCapability_Mount) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Mount != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Mount.Size()))
		n16, err := m.Mount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *VolumeCapability_BlockVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeCapability_BlockVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *VolumeCapability_MountVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeCapability_MountVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FsType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.FsType)))
		i += copy(dAtA[i:], m.FsType)
	}
	if len(m.MountFlags) > 0 {
		for _, s := range m.MountFlags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CapacityRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapacityRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequiredBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.RequiredBytes))
	}
	if m.LimitBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.LimitBytes))
	}
	return i, nil
}

func (m *VolumeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CapacityBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.CapacityBytes))
	}
	if m.AccessMode != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.AccessMode.Size()))
		n17, err := m.AccessMode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Id != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Id.Size()))
		n18, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Metadata.Size()))
		n19, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *AccessMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessMode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *VolumeID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *VolumeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *DeleteVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n20, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.VolumeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeId.Size()))
		n21, err := m.VolumeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.VolumeMetadata != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeMetadata.Size()))
		n22, err := m.VolumeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *DeleteVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn23, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	return i, nil
}

func (m *DeleteVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n24, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *DeleteVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n25, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *DeleteVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ControllerPublishVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerPublishVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n26, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.VolumeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeId.Size()))
		n27, err := m.VolumeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.VolumeMetadata != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeMetadata.Size()))
		n28, err := m.VolumeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.NodeId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.NodeId.Size()))
		n29, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Readonly {
		dAtA[i] = 0x28
		i++
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ControllerPublishVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerPublishVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn30, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn30
	}
	return i, nil
}

func (m *ControllerPublishVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n31, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *ControllerPublishVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n32, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *ControllerPublishVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerPublishVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PublishVolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.PublishVolumeInfo.Size()))
		n33, err := m.PublishVolumeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *NodeID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *PublishVolumeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishVolumeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0xa
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			i = encodeVarintCsi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *ControllerUnpublishVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerUnpublishVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n34, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.VolumeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeId.Size()))
		n35, err := m.VolumeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.VolumeMetadata != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeMetadata.Size()))
		n36, err := m.VolumeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.NodeId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.NodeId.Size()))
		n37, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *ControllerUnpublishVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerUnpublishVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn38, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn38
	}
	return i, nil
}

func (m *ControllerUnpublishVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n39, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *ControllerUnpublishVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n40, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}
func (m *ControllerUnpublishVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerUnpublishVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ValidateVolumeCapabilitiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateVolumeCapabilitiesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n41, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.VolumeInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeInfo.Size()))
		n42, err := m.VolumeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.VolumeCapabilities) > 0 {
		for _, msg := range m.VolumeCapabilities {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ValidateVolumeCapabilitiesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateVolumeCapabilitiesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn43, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn43
	}
	return i, nil
}

func (m *ValidateVolumeCapabilitiesResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n44, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}
func (m *ValidateVolumeCapabilitiesResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n45, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *ValidateVolumeCapabilitiesResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateVolumeCapabilitiesResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Supported {
		dAtA[i] = 0x8
		i++
		if m.Supported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ListVolumesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n46, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.MaxEntries != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.MaxEntries))
	}
	if len(m.StartingToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.StartingToken)))
		i += copy(dAtA[i:], m.StartingToken)
	}
	return i, nil
}

func (m *ListVolumesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn47, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn47
	}
	return i, nil
}

func (m *ListVolumesResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n48, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *ListVolumesResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n49, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *ListVolumesResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumesResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.NextToken)))
		i += copy(dAtA[i:], m.NextToken)
	}
	return i, nil
}

func (m *ListVolumesResponse_Result_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVolumesResponse_Result_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeInfo.Size()))
		n50, err := m.VolumeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *GetCapacityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCapacityRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n51, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *GetCapacityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCapacityResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn52, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn52
	}
	return i, nil
}

func (m *GetCapacityResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n53, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}
func (m *GetCapacityResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n54, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}
func (m *GetCapacityResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCapacityResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCapacity != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.TotalCapacity))
	}
	return i, nil
}

func (m *ControllerGetCapabilitiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerGetCapabilitiesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n55, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *ControllerGetCapabilitiesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerGetCapabilitiesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn56, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn56
	}
	return i, nil
}

func (m *ControllerGetCapabilitiesResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n57, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *ControllerGetCapabilitiesResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n58, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *ControllerGetCapabilitiesResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerGetCapabilitiesResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, msg := range m.Capabilities {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ControllerServiceCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerServiceCapability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn59, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn59
	}
	return i, nil
}

func (m *ControllerServiceCapability_Rpc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rpc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Rpc.Size()))
		n60, err := m.Rpc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *ControllerServiceCapability_VolumeCapability) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VolumeCapability != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeCapability.Size()))
		n61, err := m.VolumeCapability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *ControllerServiceCapability_RPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControllerServiceCapability_RPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *NodePublishVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodePublishVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n62, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.VolumeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeId.Size()))
		n63, err := m.VolumeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.VolumeMetadata != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeMetadata.Size()))
		n64, err := m.VolumeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.PublishVolumeInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.PublishVolumeInfo.Size()))
		n65, err := m.PublishVolumeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if len(m.TargetPath) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.TargetPath)))
		i += copy(dAtA[i:], m.TargetPath)
	}
	if m.VolumeCapability != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeCapability.Size()))
		n66, err := m.VolumeCapability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Readonly {
		dAtA[i] = 0x38
		i++
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NodePublishVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodePublishVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn67, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn67
	}
	return i, nil
}

func (m *NodePublishVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n68, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}
func (m *NodePublishVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n69, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}
func (m *NodePublishVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodePublishVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodeUnpublishVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeUnpublishVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n70, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.VolumeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeId.Size()))
		n71, err := m.VolumeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.VolumeMetadata != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeMetadata.Size()))
		n72, err := m.VolumeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if len(m.TargetPath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.TargetPath)))
		i += copy(dAtA[i:], m.TargetPath)
	}
	return i, nil
}

func (m *NodeUnpublishVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeUnpublishVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn73, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn73
	}
	return i, nil
}

func (m *NodeUnpublishVolumeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n74, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}
func (m *NodeUnpublishVolumeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n75, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}
func (m *NodeUnpublishVolumeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeUnpublishVolumeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetNodeIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNodeIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n76, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *GetNodeIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNodeIDResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn77, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn77
	}
	return i, nil
}

func (m *GetNodeIDResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n78, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}
func (m *GetNodeIDResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n79, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	return i, nil
}
func (m *GetNodeIDResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNodeIDResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.NodeId.Size()))
		n80, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *ProbeNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n81, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}

func (m *ProbeNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn82, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn82
	}
	return i, nil
}

func (m *ProbeNodeResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n83, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}
func (m *ProbeNodeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n84, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	return i, nil
}
func (m *ProbeNodeResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeNodeResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodeGetCapabilitiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGetCapabilitiesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Version.Size()))
		n85, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}

func (m *NodeGetCapabilitiesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGetCapabilitiesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reply != nil {
		nn86, err := m.Reply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn86
	}
	return i, nil
}

func (m *NodeGetCapabilitiesResponse_Result_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Result.Size()))
		n87, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	return i, nil
}
func (m *NodeGetCapabilitiesResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Error.Size()))
		n88, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}
func (m *NodeGetCapabilitiesResponse_Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGetCapabilitiesResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, msg := range m.Capabilities {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeServiceCapability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeServiceCapability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn89, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn89
	}
	return i, nil
}

func (m *NodeServiceCapability_Rpc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rpc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Rpc.Size()))
		n90, err := m.Rpc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	return i, nil
}
func (m *NodeServiceCapability_VolumeCapability) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VolumeCapability != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.VolumeCapability.Size()))
		n91, err := m.VolumeCapability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	return i, nil
}
func (m *NodeServiceCapability_RPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeServiceCapability_RPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn92, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn92
	}
	return i, nil
}

func (m *Error_GeneralError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GeneralError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.GeneralError.Size()))
		n93, err := m.GeneralError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}
func (m *Error_CreateVolumeError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateVolumeError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.CreateVolumeError.Size()))
		n94, err := m.CreateVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}
func (m *Error_DeleteVolumeError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeleteVolumeError != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.DeleteVolumeError.Size()))
		n95, err := m.DeleteVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	return i, nil
}
func (m *Error_ControllerPublishVolumeVolumeError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ControllerPublishVolumeVolumeError != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ControllerPublishVolumeVolumeError.Size()))
		n96, err := m.ControllerPublishVolumeVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	return i, nil
}
func (m *Error_ControllerUnpublishVolumeVolumeError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ControllerUnpublishVolumeVolumeError != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ControllerUnpublishVolumeVolumeError.Size()))
		n97, err := m.ControllerUnpublishVolumeVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	return i, nil
}
func (m *Error_ValidateVolumeCapabilitiesError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ValidateVolumeCapabilitiesError != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ValidateVolumeCapabilitiesError.Size()))
		n98, err := m.ValidateVolumeCapabilitiesError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}
func (m *Error_NodePublishVolumeError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NodePublishVolumeError != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.NodePublishVolumeError.Size()))
		n99, err := m.NodePublishVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	return i, nil
}
func (m *Error_NodeUnpublishVolumeError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NodeUnpublishVolumeError != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.NodeUnpublishVolumeError.Size()))
		n100, err := m.NodeUnpublishVolumeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	return i, nil
}
func (m *Error_ProbeNodeError_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ProbeNodeError != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ProbeNodeError.Size()))
		n101, err := m.ProbeNodeError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	return i, nil
}
func (m *Error_GeneralError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_GeneralError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if m.CallerMustNotRetry {
		dAtA[i] = 0x10
		i++
		if m.CallerMustNotRetry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_CreateVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_CreateVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_DeleteVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_DeleteVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_ControllerPublishVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_ControllerPublishVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	if len(m.NodeIds) > 0 {
		for _, msg := range m.NodeIds {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCsi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Error_ControllerUnpublishVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_ControllerUnpublishVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_ValidateVolumeCapabilitiesError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_ValidateVolumeCapabilitiesError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_NodePublishVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_NodePublishVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_NodeUnpublishVolumeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_NodeUnpublishVolumeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_ProbeNodeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_ProbeNodeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func (m *Error_GetNodeIDError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error_GetNodeIDError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCsi(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorDescription) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCsi(dAtA, i, uint64(len(m.ErrorDescription)))
		i += copy(dAtA[i:], m.ErrorDescription)
	}
	return i, nil
}

func encodeFixed64Csi(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Csi(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCsi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetSupportedVersionsRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetSupportedVersionsResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *GetSupportedVersionsResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetSupportedVersionsResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetSupportedVersionsResponse_Result) Size() (n int) {
	var l int
	_ = l
	if len(m.SupportedVersions) > 0 {
		for _, e := range m.SupportedVersions {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *Version) Size() (n int) {
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovCsi(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovCsi(uint64(m.Minor))
	}
	if m.Patch != 0 {
		n += 1 + sovCsi(uint64(m.Patch))
	}
	return n
}

func (m *GetPluginInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *GetPluginInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *GetPluginInfoResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetPluginInfoResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetPluginInfoResponse_Result) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	l = len(m.VendorVersion)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	if len(m.Manifest) > 0 {
		for k, v := range m.Manifest {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CreateVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.CapacityRange != nil {
		l = m.CapacityRange.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if len(m.VolumeCapabilities) > 0 {
		for _, e := range m.VolumeCapabilities {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CreateVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *CreateVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *CreateVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *CreateVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.VolumeInfo != nil {
		l = m.VolumeInfo.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *VolumeCapability) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *VolumeCapability_Block) Size() (n int) {
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *VolumeCapability_Mount) Size() (n int) {
	var l int
	_ = l
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *VolumeCapability_BlockVolume) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *VolumeCapability_MountVolume) Size() (n int) {
	var l int
	_ = l
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	if len(m.MountFlags) > 0 {
		for _, s := range m.MountFlags {
			l = len(s)
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *CapacityRange) Size() (n int) {
	var l int
	_ = l
	if m.RequiredBytes != 0 {
		n += 1 + sovCsi(uint64(m.RequiredBytes))
	}
	if m.LimitBytes != 0 {
		n += 1 + sovCsi(uint64(m.LimitBytes))
	}
	return n
}

func (m *VolumeInfo) Size() (n int) {
	var l int
	_ = l
	if m.CapacityBytes != 0 {
		n += 1 + sovCsi(uint64(m.CapacityBytes))
	}
	if m.AccessMode != nil {
		l = m.AccessMode.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *AccessMode) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovCsi(uint64(m.Mode))
	}
	return n
}

func (m *VolumeID) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VolumeMetadata) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeleteVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeId != nil {
		l = m.VolumeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeMetadata != nil {
		l = m.VolumeMetadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *DeleteVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *DeleteVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *DeleteVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *DeleteVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ControllerPublishVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeId != nil {
		l = m.VolumeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeMetadata != nil {
		l = m.VolumeMetadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.Readonly {
		n += 2
	}
	return n
}

func (m *ControllerPublishVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ControllerPublishVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerPublishVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerPublishVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.PublishVolumeInfo != nil {
		l = m.PublishVolumeInfo.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *NodeID) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PublishVolumeInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCsi(uint64(len(k))) + 1 + len(v) + sovCsi(uint64(len(v)))
			n += mapEntrySize + 1 + sovCsi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ControllerUnpublishVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeId != nil {
		l = m.VolumeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeMetadata != nil {
		l = m.VolumeMetadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ControllerUnpublishVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ControllerUnpublishVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerUnpublishVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerUnpublishVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ValidateVolumeCapabilitiesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeInfo != nil {
		l = m.VolumeInfo.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if len(m.VolumeCapabilities) > 0 {
		for _, e := range m.VolumeCapabilities {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *ValidateVolumeCapabilitiesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ValidateVolumeCapabilitiesResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ValidateVolumeCapabilitiesResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ValidateVolumeCapabilitiesResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.Supported {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ListVolumesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.MaxEntries != 0 {
		n += 1 + sovCsi(uint64(m.MaxEntries))
	}
	l = len(m.StartingToken)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ListVolumesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ListVolumesResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ListVolumesResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ListVolumesResponse_Result) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	l = len(m.NextToken)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ListVolumesResponse_Result_Entry) Size() (n int) {
	var l int
	_ = l
	if m.VolumeInfo != nil {
		l = m.VolumeInfo.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *GetCapacityRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *GetCapacityResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *GetCapacityResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetCapacityResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetCapacityResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.TotalCapacity != 0 {
		n += 1 + sovCsi(uint64(m.TotalCapacity))
	}
	return n
}

func (m *ControllerGetCapabilitiesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ControllerGetCapabilitiesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ControllerGetCapabilitiesResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerGetCapabilitiesResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerGetCapabilitiesResponse_Result) Size() (n int) {
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, e := range m.Capabilities {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *ControllerServiceCapability) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *ControllerServiceCapability_Rpc) Size() (n int) {
	var l int
	_ = l
	if m.Rpc != nil {
		l = m.Rpc.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerServiceCapability_VolumeCapability) Size() (n int) {
	var l int
	_ = l
	if m.VolumeCapability != nil {
		l = m.VolumeCapability.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ControllerServiceCapability_RPC) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCsi(uint64(m.Type))
	}
	return n
}

func (m *NodePublishVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeId != nil {
		l = m.VolumeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeMetadata != nil {
		l = m.VolumeMetadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.PublishVolumeInfo != nil {
		l = m.PublishVolumeInfo.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	l = len(m.TargetPath)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeCapability != nil {
		l = m.VolumeCapability.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.Readonly {
		n += 2
	}
	return n
}

func (m *NodePublishVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *NodePublishVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodePublishVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodePublishVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NodeUnpublishVolumeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeId != nil {
		l = m.VolumeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	if m.VolumeMetadata != nil {
		l = m.VolumeMetadata.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	l = len(m.TargetPath)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *NodeUnpublishVolumeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *NodeUnpublishVolumeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeUnpublishVolumeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeUnpublishVolumeResponse_Result) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetNodeIDRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *GetNodeIDResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *GetNodeIDResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetNodeIDResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *GetNodeIDResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ProbeNodeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *ProbeNodeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *ProbeNodeResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ProbeNodeResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *ProbeNodeResponse_Result) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NodeGetCapabilitiesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *NodeGetCapabilitiesResponse) Size() (n int) {
	var l int
	_ = l
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *NodeGetCapabilitiesResponse_Result_) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeGetCapabilitiesResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeGetCapabilitiesResponse_Result) Size() (n int) {
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, e := range m.Capabilities {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *NodeServiceCapability) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *NodeServiceCapability_Rpc) Size() (n int) {
	var l int
	_ = l
	if m.Rpc != nil {
		l = m.Rpc.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeServiceCapability_VolumeCapability) Size() (n int) {
	var l int
	_ = l
	if m.VolumeCapability != nil {
		l = m.VolumeCapability.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *NodeServiceCapability_RPC) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCsi(uint64(m.Type))
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Error_GeneralError_) Size() (n int) {
	var l int
	_ = l
	if m.GeneralError != nil {
		l = m.GeneralError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_CreateVolumeError_) Size() (n int) {
	var l int
	_ = l
	if m.CreateVolumeError != nil {
		l = m.CreateVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_DeleteVolumeError_) Size() (n int) {
	var l int
	_ = l
	if m.DeleteVolumeError != nil {
		l = m.DeleteVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_ControllerPublishVolumeVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ControllerPublishVolumeVolumeError != nil {
		l = m.ControllerPublishVolumeVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_ControllerUnpublishVolumeVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ControllerUnpublishVolumeVolumeError != nil {
		l = m.ControllerUnpublishVolumeVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_ValidateVolumeCapabilitiesError_) Size() (n int) {
	var l int
	_ = l
	if m.ValidateVolumeCapabilitiesError != nil {
		l = m.ValidateVolumeCapabilitiesError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_NodePublishVolumeError_) Size() (n int) {
	var l int
	_ = l
	if m.NodePublishVolumeError != nil {
		l = m.NodePublishVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_NodeUnpublishVolumeError_) Size() (n int) {
	var l int
	_ = l
	if m.NodeUnpublishVolumeError != nil {
		l = m.NodeUnpublishVolumeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_ProbeNodeError_) Size() (n int) {
	var l int
	_ = l
	if m.ProbeNodeError != nil {
		l = m.ProbeNodeError.Size()
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}
func (m *Error_GeneralError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	if m.CallerMustNotRetry {
		n += 2
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_CreateVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_DeleteVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_ControllerPublishVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	if len(m.NodeIds) > 0 {
		for _, e := range m.NodeIds {
			l = e.Size()
			n += 1 + l + sovCsi(uint64(l))
		}
	}
	return n
}

func (m *Error_ControllerUnpublishVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_ValidateVolumeCapabilitiesError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_NodePublishVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_NodeUnpublishVolumeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_ProbeNodeError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func (m *Error_GetNodeIDError) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovCsi(uint64(m.ErrorCode))
	}
	l = len(m.ErrorDescription)
	if l > 0 {
		n += 1 + l + sovCsi(uint64(l))
	}
	return n
}

func sovCsi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCsi(x uint64) (n int) {
	return sovCsi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetSupportedVersionsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSupportedVersionsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetSupportedVersionsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSupportedVersionsResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSupportedVersionsResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSupportedVersionsResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "GetSupportedVersionsResponse_Result", "GetSupportedVersionsResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSupportedVersionsResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSupportedVersionsResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSupportedVersionsResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSupportedVersionsResponse_Result{`,
		`SupportedVersions:` + strings.Replace(fmt.Sprintf("%v", this.SupportedVersions), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Version) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Version{`,
		`Major:` + fmt.Sprintf("%v", this.Major) + `,`,
		`Minor:` + fmt.Sprintf("%v", this.Minor) + `,`,
		`Patch:` + fmt.Sprintf("%v", this.Patch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPluginInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPluginInfoRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPluginInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPluginInfoResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPluginInfoResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPluginInfoResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "GetPluginInfoResponse_Result", "GetPluginInfoResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPluginInfoResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPluginInfoResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetPluginInfoResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	keysForManifest := make([]string, 0, len(this.Manifest))
	for k, _ := range this.Manifest {
		keysForManifest = append(keysForManifest, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForManifest)
	mapStringForManifest := "map[string]string{"
	for _, k := range keysForManifest {
		mapStringForManifest += fmt.Sprintf("%v: %v,", k, this.Manifest[k])
	}
	mapStringForManifest += "}"
	s := strings.Join([]string{`&GetPluginInfoResponse_Result{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`VendorVersion:` + fmt.Sprintf("%v", this.VendorVersion) + `,`,
		`Manifest:` + mapStringForManifest + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForParameters := make([]string, 0, len(this.Parameters))
	for k, _ := range this.Parameters {
		keysForParameters = append(keysForParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForParameters)
	mapStringForParameters := "map[string]string{"
	for _, k := range keysForParameters {
		mapStringForParameters += fmt.Sprintf("%v: %v,", k, this.Parameters[k])
	}
	mapStringForParameters += "}"
	s := strings.Join([]string{`&CreateVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`CapacityRange:` + strings.Replace(fmt.Sprintf("%v", this.CapacityRange), "CapacityRange", "CapacityRange", 1) + `,`,
		`VolumeCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.VolumeCapabilities), "VolumeCapability", "VolumeCapability", 1) + `,`,
		`Parameters:` + mapStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "CreateVolumeResponse_Result", "CreateVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateVolumeResponse_Result{`,
		`VolumeInfo:` + strings.Replace(fmt.Sprintf("%v", this.VolumeInfo), "VolumeInfo", "VolumeInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeCapability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeCapability{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeCapability_Block) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeCapability_Block{`,
		`Block:` + strings.Replace(fmt.Sprintf("%v", this.Block), "VolumeCapability_BlockVolume", "VolumeCapability_BlockVolume", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeCapability_Mount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeCapability_Mount{`,
		`Mount:` + strings.Replace(fmt.Sprintf("%v", this.Mount), "VolumeCapability_MountVolume", "VolumeCapability_MountVolume", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeCapability_BlockVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeCapability_BlockVolume{`,
		`}`,
	}, "")
	return s
}
func (this *VolumeCapability_MountVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeCapability_MountVolume{`,
		`FsType:` + fmt.Sprintf("%v", this.FsType) + `,`,
		`MountFlags:` + fmt.Sprintf("%v", this.MountFlags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapacityRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapacityRange{`,
		`RequiredBytes:` + fmt.Sprintf("%v", this.RequiredBytes) + `,`,
		`LimitBytes:` + fmt.Sprintf("%v", this.LimitBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeInfo{`,
		`CapacityBytes:` + fmt.Sprintf("%v", this.CapacityBytes) + `,`,
		`AccessMode:` + strings.Replace(fmt.Sprintf("%v", this.AccessMode), "AccessMode", "AccessMode", 1) + `,`,
		`Id:` + strings.Replace(fmt.Sprintf("%v", this.Id), "VolumeID", "VolumeID", 1) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccessMode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccessMode{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeID) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{`&VolumeID{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeMetadata) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{`&VolumeMetadata{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeId:` + strings.Replace(fmt.Sprintf("%v", this.VolumeId), "VolumeID", "VolumeID", 1) + `,`,
		`VolumeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMetadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "DeleteVolumeResponse_Result", "DeleteVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteVolumeResponse_Result{`,
		`}`,
	}, "")
	return s
}
func (this *ControllerPublishVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerPublishVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeId:` + strings.Replace(fmt.Sprintf("%v", this.VolumeId), "VolumeID", "VolumeID", 1) + `,`,
		`VolumeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMetadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`NodeId:` + strings.Replace(fmt.Sprintf("%v", this.NodeId), "NodeID", "NodeID", 1) + `,`,
		`Readonly:` + fmt.Sprintf("%v", this.Readonly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerPublishVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerPublishVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerPublishVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerPublishVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ControllerPublishVolumeResponse_Result", "ControllerPublishVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerPublishVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerPublishVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerPublishVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerPublishVolumeResponse_Result{`,
		`PublishVolumeInfo:` + strings.Replace(fmt.Sprintf("%v", this.PublishVolumeInfo), "PublishVolumeInfo", "PublishVolumeInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeID) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{`&NodeID{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublishVolumeInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForValues := make([]string, 0, len(this.Values))
	for k, _ := range this.Values {
		keysForValues = append(keysForValues, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
	mapStringForValues := "map[string]string{"
	for _, k := range keysForValues {
		mapStringForValues += fmt.Sprintf("%v: %v,", k, this.Values[k])
	}
	mapStringForValues += "}"
	s := strings.Join([]string{`&PublishVolumeInfo{`,
		`Values:` + mapStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerUnpublishVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerUnpublishVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeId:` + strings.Replace(fmt.Sprintf("%v", this.VolumeId), "VolumeID", "VolumeID", 1) + `,`,
		`VolumeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMetadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`NodeId:` + strings.Replace(fmt.Sprintf("%v", this.NodeId), "NodeID", "NodeID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerUnpublishVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerUnpublishVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerUnpublishVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerUnpublishVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ControllerUnpublishVolumeResponse_Result", "ControllerUnpublishVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerUnpublishVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerUnpublishVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerUnpublishVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerUnpublishVolumeResponse_Result{`,
		`}`,
	}, "")
	return s
}
func (this *ValidateVolumeCapabilitiesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateVolumeCapabilitiesRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeInfo:` + strings.Replace(fmt.Sprintf("%v", this.VolumeInfo), "VolumeInfo", "VolumeInfo", 1) + `,`,
		`VolumeCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.VolumeCapabilities), "VolumeCapability", "VolumeCapability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateVolumeCapabilitiesResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateVolumeCapabilitiesResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ValidateVolumeCapabilitiesResponse_Result", "ValidateVolumeCapabilitiesResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateVolumeCapabilitiesResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateVolumeCapabilitiesResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateVolumeCapabilitiesResponse_Result{`,
		`Supported:` + fmt.Sprintf("%v", this.Supported) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`MaxEntries:` + fmt.Sprintf("%v", this.MaxEntries) + `,`,
		`StartingToken:` + fmt.Sprintf("%v", this.StartingToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ListVolumesResponse_Result", "ListVolumesResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesResponse_Result{`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "ListVolumesResponse_Result_Entry", "ListVolumesResponse_Result_Entry", 1) + `,`,
		`NextToken:` + fmt.Sprintf("%v", this.NextToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVolumesResponse_Result_Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVolumesResponse_Result_Entry{`,
		`VolumeInfo:` + strings.Replace(fmt.Sprintf("%v", this.VolumeInfo), "VolumeInfo", "VolumeInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCapacityRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCapacityRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCapacityResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCapacityResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCapacityResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCapacityResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "GetCapacityResponse_Result", "GetCapacityResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCapacityResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCapacityResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetCapacityResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetCapacityResponse_Result{`,
		`TotalCapacity:` + fmt.Sprintf("%v", this.TotalCapacity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerGetCapabilitiesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerGetCapabilitiesRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerGetCapabilitiesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerGetCapabilitiesResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerGetCapabilitiesResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerGetCapabilitiesResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ControllerGetCapabilitiesResponse_Result", "ControllerGetCapabilitiesResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerGetCapabilitiesResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerGetCapabilitiesResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerGetCapabilitiesResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerGetCapabilitiesResponse_Result{`,
		`Capabilities:` + strings.Replace(fmt.Sprintf("%v", this.Capabilities), "ControllerServiceCapability", "ControllerServiceCapability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerServiceCapability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerServiceCapability{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerServiceCapability_Rpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerServiceCapability_Rpc{`,
		`Rpc:` + strings.Replace(fmt.Sprintf("%v", this.Rpc), "ControllerServiceCapability_RPC", "ControllerServiceCapability_RPC", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerServiceCapability_VolumeCapability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerServiceCapability_VolumeCapability{`,
		`VolumeCapability:` + strings.Replace(fmt.Sprintf("%v", this.VolumeCapability), "VolumeCapability", "VolumeCapability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ControllerServiceCapability_RPC) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ControllerServiceCapability_RPC{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePublishVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePublishVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeId:` + strings.Replace(fmt.Sprintf("%v", this.VolumeId), "VolumeID", "VolumeID", 1) + `,`,
		`VolumeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMetadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`PublishVolumeInfo:` + strings.Replace(fmt.Sprintf("%v", this.PublishVolumeInfo), "PublishVolumeInfo", "PublishVolumeInfo", 1) + `,`,
		`TargetPath:` + fmt.Sprintf("%v", this.TargetPath) + `,`,
		`VolumeCapability:` + strings.Replace(fmt.Sprintf("%v", this.VolumeCapability), "VolumeCapability", "VolumeCapability", 1) + `,`,
		`Readonly:` + fmt.Sprintf("%v", this.Readonly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePublishVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePublishVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePublishVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePublishVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "NodePublishVolumeResponse_Result", "NodePublishVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePublishVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePublishVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePublishVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePublishVolumeResponse_Result{`,
		`}`,
	}, "")
	return s
}
func (this *NodeUnpublishVolumeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeUnpublishVolumeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`VolumeId:` + strings.Replace(fmt.Sprintf("%v", this.VolumeId), "VolumeID", "VolumeID", 1) + `,`,
		`VolumeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMetadata), "VolumeMetadata", "VolumeMetadata", 1) + `,`,
		`TargetPath:` + fmt.Sprintf("%v", this.TargetPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeUnpublishVolumeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeUnpublishVolumeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeUnpublishVolumeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeUnpublishVolumeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "NodeUnpublishVolumeResponse_Result", "NodeUnpublishVolumeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeUnpublishVolumeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeUnpublishVolumeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeUnpublishVolumeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeUnpublishVolumeResponse_Result{`,
		`}`,
	}, "")
	return s
}
func (this *GetNodeIDRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNodeIDRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNodeIDResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNodeIDResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNodeIDResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNodeIDResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "GetNodeIDResponse_Result", "GetNodeIDResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNodeIDResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNodeIDResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetNodeIDResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetNodeIDResponse_Result{`,
		`NodeId:` + strings.Replace(fmt.Sprintf("%v", this.NodeId), "NodeID", "NodeID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeNodeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeNodeRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeNodeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeNodeResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeNodeResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeNodeResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "ProbeNodeResponse_Result", "ProbeNodeResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeNodeResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeNodeResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeNodeResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeNodeResponse_Result{`,
		`}`,
	}, "")
	return s
}
func (this *NodeGetCapabilitiesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeGetCapabilitiesRequest{`,
		`Version:` + strings.Replace(fmt.Sprintf("%v", this.Version), "Version", "Version", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeGetCapabilitiesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeGetCapabilitiesResponse{`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeGetCapabilitiesResponse_Result_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeGetCapabilitiesResponse_Result_{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "NodeGetCapabilitiesResponse_Result", "NodeGetCapabilitiesResponse_Result", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeGetCapabilitiesResponse_Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeGetCapabilitiesResponse_Error{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeGetCapabilitiesResponse_Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeGetCapabilitiesResponse_Result{`,
		`Capabilities:` + strings.Replace(fmt.Sprintf("%v", this.Capabilities), "NodeServiceCapability", "NodeServiceCapability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeServiceCapability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeServiceCapability{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeServiceCapability_Rpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeServiceCapability_Rpc{`,
		`Rpc:` + strings.Replace(fmt.Sprintf("%v", this.Rpc), "NodeServiceCapability_RPC", "NodeServiceCapability_RPC", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeServiceCapability_VolumeCapability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeServiceCapability_VolumeCapability{`,
		`VolumeCapability:` + strings.Replace(fmt.Sprintf("%v", this.VolumeCapability), "VolumeCapability", "VolumeCapability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeServiceCapability_RPC) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeServiceCapability_RPC{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_GeneralError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_GeneralError_{`,
		`GeneralError:` + strings.Replace(fmt.Sprintf("%v", this.GeneralError), "Error_GeneralError", "Error_GeneralError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_CreateVolumeError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_CreateVolumeError_{`,
		`CreateVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.CreateVolumeError), "Error_CreateVolumeError", "Error_CreateVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_DeleteVolumeError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_DeleteVolumeError_{`,
		`DeleteVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.DeleteVolumeError), "Error_DeleteVolumeError", "Error_DeleteVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ControllerPublishVolumeVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ControllerPublishVolumeVolumeError{`,
		`ControllerPublishVolumeVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.ControllerPublishVolumeVolumeError), "Error_ControllerPublishVolumeError", "Error_ControllerPublishVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ControllerUnpublishVolumeVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ControllerUnpublishVolumeVolumeError{`,
		`ControllerUnpublishVolumeVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.ControllerUnpublishVolumeVolumeError), "Error_ControllerUnpublishVolumeError", "Error_ControllerUnpublishVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ValidateVolumeCapabilitiesError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ValidateVolumeCapabilitiesError_{`,
		`ValidateVolumeCapabilitiesError:` + strings.Replace(fmt.Sprintf("%v", this.ValidateVolumeCapabilitiesError), "Error_ValidateVolumeCapabilitiesError", "Error_ValidateVolumeCapabilitiesError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_NodePublishVolumeError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_NodePublishVolumeError_{`,
		`NodePublishVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.NodePublishVolumeError), "Error_NodePublishVolumeError", "Error_NodePublishVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_NodeUnpublishVolumeError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_NodeUnpublishVolumeError_{`,
		`NodeUnpublishVolumeError:` + strings.Replace(fmt.Sprintf("%v", this.NodeUnpublishVolumeError), "Error_NodeUnpublishVolumeError", "Error_NodeUnpublishVolumeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ProbeNodeError_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ProbeNodeError_{`,
		`ProbeNodeError:` + strings.Replace(fmt.Sprintf("%v", this.ProbeNodeError), "Error_ProbeNodeError", "Error_ProbeNodeError", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_GeneralError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_GeneralError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`CallerMustNotRetry:` + fmt.Sprintf("%v", this.CallerMustNotRetry) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_CreateVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_CreateVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_DeleteVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_DeleteVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ControllerPublishVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ControllerPublishVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`NodeIds:` + strings.Replace(fmt.Sprintf("%v", this.NodeIds), "NodeID", "NodeID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ControllerUnpublishVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ControllerUnpublishVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ValidateVolumeCapabilitiesError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ValidateVolumeCapabilitiesError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_NodePublishVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_NodePublishVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_NodeUnpublishVolumeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_NodeUnpublishVolumeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_ProbeNodeError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_ProbeNodeError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error_GetNodeIDError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error_GetNodeIDError{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorDescription:` + fmt.Sprintf("%v", this.ErrorDescription) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCsi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetSupportedVersionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSupportedVersionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSupportedVersionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSupportedVersionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSupportedVersionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSupportedVersionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetSupportedVersionsResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetSupportedVersionsResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetSupportedVersionsResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSupportedVersionsResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedVersions = append(m.SupportedVersions, &Version{})
			if err := m.SupportedVersions[len(m.SupportedVersions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			m.Patch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Patch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPluginInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPluginInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPluginInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPluginInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPluginInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPluginInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetPluginInfoResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetPluginInfoResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetPluginInfoResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPluginInfoResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Manifest == nil {
				m.Manifest = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Manifest[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Manifest[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CapacityRange == nil {
				m.CapacityRange = &CapacityRange{}
			}
			if err := m.CapacityRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeCapabilities = append(m.VolumeCapabilities, &VolumeCapability{})
			if err := m.VolumeCapabilities[len(m.VolumeCapabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Parameters[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Parameters[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &CreateVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &CreateVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeInfo == nil {
				m.VolumeInfo = &VolumeInfo{}
			}
			if err := m.VolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VolumeCapability_BlockVolume{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &VolumeCapability_Block{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VolumeCapability_MountVolume{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &VolumeCapability_Mount{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeCapability_BlockVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeCapability_MountVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountFlags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountFlags = append(m.MountFlags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapacityRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapacityRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapacityRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredBytes", wireType)
			}
			m.RequiredBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitBytes", wireType)
			}
			m.LimitBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityBytes", wireType)
			}
			m.CapacityBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapacityBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessMode == nil {
				m.AccessMode = &AccessMode{}
			}
			if err := m.AccessMode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &VolumeID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &VolumeMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (AccessMode_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Values == nil {
				m.Values = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Values[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Values[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Values == nil {
				m.Values = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Values[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Values[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeId == nil {
				m.VolumeId = &VolumeID{}
			}
			if err := m.VolumeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMetadata == nil {
				m.VolumeMetadata = &VolumeMetadata{}
			}
			if err := m.VolumeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &DeleteVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &DeleteVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerPublishVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerPublishVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerPublishVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeId == nil {
				m.VolumeId = &VolumeID{}
			}
			if err := m.VolumeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMetadata == nil {
				m.VolumeMetadata = &VolumeMetadata{}
			}
			if err := m.VolumeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeID{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerPublishVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerPublishVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerPublishVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControllerPublishVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerPublishVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerPublishVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerPublishVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVolumeInfo == nil {
				m.PublishVolumeInfo = &PublishVolumeInfo{}
			}
			if err := m.PublishVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Values == nil {
				m.Values = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Values[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Values[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishVolumeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishVolumeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishVolumeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCsi
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Values == nil {
				m.Values = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthCsi
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Values[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Values[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerUnpublishVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeId == nil {
				m.VolumeId = &VolumeID{}
			}
			if err := m.VolumeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMetadata == nil {
				m.VolumeMetadata = &VolumeMetadata{}
			}
			if err := m.VolumeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeID{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerUnpublishVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControllerUnpublishVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerUnpublishVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerUnpublishVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerUnpublishVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateVolumeCapabilitiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeInfo == nil {
				m.VolumeInfo = &VolumeInfo{}
			}
			if err := m.VolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeCapabilities = append(m.VolumeCapabilities, &VolumeCapability{})
			if err := m.VolumeCapabilities[len(m.VolumeCapabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateVolumeCapabilitiesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ValidateVolumeCapabilitiesResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ValidateVolumeCapabilitiesResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ValidateVolumeCapabilitiesResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateVolumeCapabilitiesResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Supported = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVolumesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVolumesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEntries", wireType)
			}
			m.MaxEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEntries |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartingToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVolumesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVolumesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListVolumesResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ListVolumesResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ListVolumesResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumesResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &ListVolumesResponse_Result_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVolumesResponse_Result_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeInfo == nil {
				m.VolumeInfo = &VolumeInfo{}
			}
			if err := m.VolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCapacityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCapacityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCapacityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCapacityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCapacityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCapacityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetCapacityResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetCapacityResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetCapacityResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCapacityResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCapacity", wireType)
			}
			m.TotalCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCapacity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerGetCapabilitiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerGetCapabilitiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerGetCapabilitiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerGetCapabilitiesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerGetCapabilitiesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerGetCapabilitiesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControllerGetCapabilitiesResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerGetCapabilitiesResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ControllerGetCapabilitiesResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerGetCapabilitiesResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, &ControllerServiceCapability{})
			if err := m.Capabilities[len(m.Capabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerServiceCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerServiceCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerServiceCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ControllerServiceCapability_RPC{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ControllerServiceCapability_Rpc{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VolumeCapability{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &ControllerServiceCapability_VolumeCapability{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControllerServiceCapability_RPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ControllerServiceCapability_RPC_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodePublishVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodePublishVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodePublishVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeId == nil {
				m.VolumeId = &VolumeID{}
			}
			if err := m.VolumeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMetadata == nil {
				m.VolumeMetadata = &VolumeMetadata{}
			}
			if err := m.VolumeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishVolumeInfo == nil {
				m.PublishVolumeInfo = &PublishVolumeInfo{}
			}
			if err := m.PublishVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeCapability == nil {
				m.VolumeCapability = &VolumeCapability{}
			}
			if err := m.VolumeCapability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodePublishVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodePublishVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodePublishVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodePublishVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodePublishVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodePublishVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodePublishVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeUnpublishVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeUnpublishVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeUnpublishVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeId == nil {
				m.VolumeId = &VolumeID{}
			}
			if err := m.VolumeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMetadata == nil {
				m.VolumeMetadata = &VolumeMetadata{}
			}
			if err := m.VolumeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeUnpublishVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeUnpublishVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeUnpublishVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeUnpublishVolumeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodeUnpublishVolumeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodeUnpublishVolumeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeUnpublishVolumeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNodeIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNodeIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNodeIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNodeIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNodeIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNodeIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetNodeIDResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetNodeIDResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &GetNodeIDResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNodeIDResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeID{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProbeNodeResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ProbeNodeResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &ProbeNodeResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeNodeResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGetCapabilitiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeGetCapabilitiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeGetCapabilitiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGetCapabilitiesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeGetCapabilitiesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeGetCapabilitiesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeGetCapabilitiesResponse_Result{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodeGetCapabilitiesResponse_Result_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &NodeGetCapabilitiesResponse_Error{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGetCapabilitiesResponse_Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, &NodeServiceCapability{})
			if err := m.Capabilities[len(m.Capabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeServiceCapability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeServiceCapability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeServiceCapability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeServiceCapability_RPC{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &NodeServiceCapability_Rpc{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCapability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VolumeCapability{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &NodeServiceCapability_VolumeCapability{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeServiceCapability_RPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NodeServiceCapability_RPC_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_GeneralError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_GeneralError_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_CreateVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_CreateVolumeError_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_DeleteVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_DeleteVolumeError_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerPublishVolumeVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_ControllerPublishVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_ControllerPublishVolumeVolumeError{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerUnpublishVolumeVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_ControllerUnpublishVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_ControllerUnpublishVolumeVolumeError{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateVolumeCapabilitiesError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_ValidateVolumeCapabilitiesError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_ValidateVolumeCapabilitiesError_{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePublishVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_NodePublishVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_NodePublishVolumeError_{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUnpublishVolumeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_NodeUnpublishVolumeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_NodeUnpublishVolumeError_{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeNodeError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error_ProbeNodeError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Error_ProbeNodeError_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_GeneralError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneralError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneralError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_GeneralError_GeneralErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerMustNotRetry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CallerMustNotRetry = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_CreateVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_CreateVolumeError_CreateVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_DeleteVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_DeleteVolumeError_DeleteVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_ControllerPublishVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerPublishVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerPublishVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_ControllerPublishVolumeError_ControllerPublishVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeIds = append(m.NodeIds, &NodeID{})
			if err := m.NodeIds[len(m.NodeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_ControllerUnpublishVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControllerUnpublishVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_ControllerUnpublishVolumeError_ControllerUnpublishVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_ValidateVolumeCapabilitiesError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateVolumeCapabilitiesError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_ValidateVolumeCapabilitiesError_ValidateVolumeCapabilitiesErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_NodePublishVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodePublishVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodePublishVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_NodePublishVolumeError_NodePublishVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_NodeUnpublishVolumeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeUnpublishVolumeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeUnpublishVolumeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_NodeUnpublishVolumeError_NodeUnpublishVolumeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_ProbeNodeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeNodeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeNodeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_ProbeNodeError_ProbeNodeErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error_GetNodeIDError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNodeIDError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNodeIDError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (Error_GetNodeIDError_GetNodeIDErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCsi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCsi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCsi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCsi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCsi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCsi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCsi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCsi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCsi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCsi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCsi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("csi.proto", fileDescriptorCsi) }

var fileDescriptorCsi = []byte{
	// 3129 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5b, 0xdd, 0x6f, 0x23, 0x57,
	0x15, 0xf7, 0xd8, 0x8e, 0x3f, 0x8e, 0x37, 0xd9, 0xf1, 0x75, 0xb2, 0x71, 0x26, 0x59, 0x27, 0x3b,
	0xdd, 0x2d, 0xdb, 0x6e, 0x19, 0x44, 0xb6, 0xdb, 0x6e, 0xb7, 0xb4, 0x5a, 0xc7, 0x9e, 0x38, 0x6e,
	0xfd, 0xc5, 0xd8, 0xce, 0x76, 0x8b, 0xd4, 0x61, 0xd6, 0x9e, 0xcd, 0x9a, 0x75, 0x6c, 0x77, 0x66,
	0x12, 0x35, 0xea, 0x03, 0x85, 0x07, 0x84, 0xc4, 0x03, 0x48, 0x3c, 0xf0, 0x50, 0x21, 0xa8, 0x90,
	0x10, 0x88, 0x87, 0x8a, 0x47, 0x1e, 0x11, 0x42, 0x82, 0x56, 0x48, 0x05, 0x81, 0x84, 0x84, 0x2a,
	0xd8, 0x50, 0xa1, 0x3e, 0xf0, 0xd0, 0x3f, 0x01, 0xcd, 0x9d, 0x3b, 0xe3, 0xf9, 0xb4, 0xe3, 0x26,
	0x0f, 0xcb, 0x9b, 0xe7, 0xdc, 0xf3, 0x71, 0xef, 0xef, 0xdc, 0x7b, 0xce, 0xb9, 0x1f, 0x86, 0x64,
	0x47, 0xed, 0x71, 0x23, 0x65, 0xa8, 0x0d, 0xd9, 0x8b, 0xb0, 0x5a, 0x92, 0xb5, 0xe6, 0xc1, 0x68,
	0x34, 0x54, 0x34, 0xb9, 0xbb, 0x2b, 0x2b, 0x6a, 0x6f, 0x38, 0x50, 0x05, 0xf9, 0xcd, 0x03, 0x59,
	0xd5, 0xd8, 0x0f, 0x28, 0x58, 0xf3, 0x6f, 0x57, 0x47, 0xc3, 0x81, 0x2a, 0xa3, 0x97, 0x21, 0xa6,
	0xc8, 0xea, 0x41, 0x5f, 0xcb, 0x52, 0x1b, 0xd4, 0xd5, 0xd4, 0xe6, 0x65, 0x6e, 0x12, 0x3b, 0x27,
	0x60, 0xde, 0x9d, 0x90, 0x40, 0xa4, 0x50, 0x0e, 0xe6, 0x64, 0x45, 0x19, 0x2a, 0xd9, 0x30, 0x16,
	0x8f, 0x71, 0xbc, 0xfe, 0xb5, 0x13, 0x12, 0x0c, 0x32, 0x93, 0x87, 0x98, 0x21, 0x83, 0x9e, 0x07,
	0xa4, 0x9a, 0x7a, 0xc5, 0x43, 0xa2, 0x38, 0x4b, 0x6d, 0x44, 0xae, 0xa6, 0x36, 0x13, 0x1c, 0xb1,
	0x24, 0xa4, 0x55, 0xb7, 0xed, 0xad, 0x38, 0xcc, 0x29, 0xf2, 0xa8, 0x7f, 0xc4, 0xbe, 0x0a, 0x71,
	0x42, 0x44, 0x8b, 0x30, 0xb7, 0x2f, 0x7d, 0x63, 0xa8, 0xe0, 0x5e, 0xcf, 0x0b, 0xc6, 0x07, 0xa6,
	0xf6, 0x06, 0xa4, 0x33, 0x3a, 0x55, 0xff, 0xd0, 0xa9, 0x23, 0x49, 0xeb, 0x3c, 0xc8, 0x46, 0x0c,
	0x2a, 0xfe, 0x60, 0x6f, 0xc1, 0x62, 0x49, 0xd6, 0x1a, 0xfd, 0x83, 0xbd, 0xde, 0xa0, 0x3c, 0xb8,
	0x3f, 0x24, 0x88, 0x21, 0x16, 0xe2, 0xa4, 0x73, 0x04, 0x91, 0x71, 0xdf, 0xcc, 0x06, 0xf6, 0xf7,
	0x61, 0x58, 0x72, 0x09, 0x13, 0x38, 0x9f, 0x77, 0xc1, 0x79, 0x91, 0xf3, 0xe5, 0x9b, 0x1d, 0xc7,
	0x3f, 0x52, 0x16, 0x90, 0x08, 0xa2, 0x03, 0x69, 0x5f, 0xc6, 0x16, 0x92, 0x02, 0xfe, 0x8d, 0xae,
	0xc0, 0xc2, 0xa1, 0x3c, 0xe8, 0x0e, 0x15, 0x13, 0x59, 0xac, 0x27, 0x29, 0xcc, 0x1b, 0x54, 0x13,
	0xb6, 0x12, 0x24, 0xf6, 0xa5, 0x41, 0xef, 0xbe, 0xac, 0x6a, 0xd9, 0x08, 0x46, 0xfe, 0xda, 0xc4,
	0x0e, 0x72, 0x55, 0xc2, 0xcd, 0x0f, 0x34, 0xe5, 0x48, 0xb0, 0x84, 0x99, 0x17, 0x61, 0xde, 0xd1,
	0x84, 0x68, 0x88, 0x3c, 0x94, 0x8f, 0x48, 0x9f, 0xf4, 0x9f, 0x3a, 0xec, 0x87, 0x52, 0xff, 0x40,
	0x26, 0x3d, 0x31, 0x3e, 0x6e, 0x85, 0x6f, 0x52, 0x63, 0x87, 0xfe, 0x29, 0x0c, 0x99, 0x82, 0x22,
	0x4b, 0x9a, 0xbc, 0x3b, 0xec, 0x1f, 0xec, 0xcb, 0x33, 0xf8, 0xc0, 0x42, 0x21, 0x6c, 0x43, 0xe1,
	0x06, 0x2c, 0x74, 0xa4, 0x91, 0xd4, 0xe9, 0x69, 0x47, 0xa2, 0x22, 0x0d, 0xf6, 0x64, 0xec, 0xf2,
	0xd4, 0xe6, 0x02, 0x57, 0x20, 0x64, 0x41, 0xa7, 0x0a, 0xf3, 0x1d, 0xfb, 0x27, 0xda, 0x82, 0xcc,
	0x21, 0xb6, 0x2f, 0xea, 0xf4, 0x7b, 0xbd, 0x7e, 0x4f, 0xeb, 0xc9, 0x6a, 0x36, 0x8a, 0x01, 0x4a,
	0x73, 0x46, 0xdf, 0x0a, 0x66, 0xd3, 0x91, 0x80, 0x0e, 0x9d, 0x94, 0x9e, 0xac, 0xa2, 0x22, 0xc0,
	0x48, 0x52, 0xa4, 0x7d, 0x59, 0x93, 0x15, 0x35, 0x3b, 0x87, 0x45, 0x2f, 0x73, 0x3e, 0x83, 0xe3,
	0x1a, 0x16, 0x9b, 0x01, 0xaa, 0x4d, 0x8e, 0x79, 0x09, 0xce, 0xbb, 0x9a, 0x67, 0x01, 0x96, 0x7d,
	0x9f, 0x82, 0x45, 0xa7, 0x49, 0x32, 0x2d, 0x9f, 0x73, 0x4d, 0xcb, 0x35, 0xce, 0x8f, 0x6d, 0xf6,
	0x59, 0xf9, 0x9c, 0x35, 0x29, 0x9f, 0x81, 0x14, 0xc1, 0xb0, 0x37, 0xb8, 0x3f, 0x24, 0x66, 0x52,
	0x04, 0x3b, 0x3c, 0xb3, 0xe0, 0xd0, 0xfa, 0x3d, 0x9e, 0x01, 0x8f, 0x28, 0xa0, 0xdd, 0xf8, 0xa2,
	0x1b, 0x30, 0x77, 0xaf, 0x3f, 0xec, 0x3c, 0xb4, 0xd6, 0x90, 0x9b, 0x83, 0xdb, 0xd2, 0x9b, 0x0d,
	0xaa, 0xde, 0x19, 0xcc, 0xad, 0x8b, 0xed, 0x0f, 0x0f, 0x06, 0x1a, 0xe9, 0xac, 0x8f, 0x58, 0x55,
	0x6f, 0x1e, 0x8b, 0x61, 0x6e, 0x66, 0x1e, 0x52, 0x36, 0x75, 0x4c, 0x09, 0x52, 0x36, 0x36, 0xb4,
	0x0c, 0xf1, 0xfb, 0xaa, 0xa8, 0x1d, 0x8d, 0xcc, 0xf5, 0x16, 0xbb, 0xaf, 0xb6, 0x8e, 0x46, 0x32,
	0x5a, 0x87, 0x14, 0x96, 0x17, 0xef, 0xf7, 0xa5, 0x3d, 0x35, 0x1b, 0xde, 0x88, 0x5c, 0x4d, 0x0a,
	0x80, 0x49, 0xdb, 0x3a, 0x45, 0x1f, 0x23, 0xf6, 0x0c, 0x7b, 0x07, 0xe6, 0x1d, 0xd3, 0x4f, 0x5f,
	0xac, 0x8a, 0xfc, 0xe6, 0x41, 0x4f, 0x91, 0xbb, 0xe2, 0xbd, 0x23, 0x4d, 0x56, 0xb1, 0xea, 0xa8,
	0x30, 0x6f, 0x52, 0xb7, 0x74, 0xa2, 0x6e, 0xa1, 0xdf, 0xdb, 0xef, 0x69, 0x84, 0x27, 0x8c, 0x79,
	0x00, 0x93, 0x30, 0x03, 0xfb, 0x4b, 0x0a, 0x60, 0x0c, 0xb0, 0xae, 0xd6, 0x9a, 0xfd, 0x0e, 0xb5,
	0x26, 0xd5, 0x50, 0xfb, 0x0c, 0xa4, 0xa4, 0x4e, 0x47, 0x56, 0x55, 0x71, 0x7f, 0xd8, 0x95, 0x09,
	0x58, 0x29, 0x2e, 0x8f, 0x69, 0xd5, 0x61, 0x57, 0x16, 0x40, 0xb2, 0x7e, 0xa3, 0x15, 0x08, 0xf7,
	0xba, 0xd9, 0x28, 0x66, 0x4a, 0x9a, 0xee, 0x2c, 0x0a, 0xe1, 0x5e, 0x17, 0x5d, 0x83, 0xc4, 0xbe,
	0xac, 0x49, 0x5d, 0x49, 0x93, 0xb2, 0x73, 0x98, 0xe1, 0x3c, 0x61, 0xa8, 0x12, 0xb2, 0x60, 0x31,
	0xb0, 0x7f, 0xa5, 0x00, 0xc6, 0x26, 0xd0, 0x65, 0x88, 0x62, 0xeb, 0x7a, 0x0f, 0x17, 0x36, 0x69,
	0x9b, 0x75, 0x0e, 0x77, 0x01, 0xb7, 0xb2, 0x3f, 0xa1, 0x20, 0x8a, 0xd9, 0x53, 0x10, 0x6f, 0xd7,
	0x5e, 0xad, 0xd5, 0xef, 0xd4, 0xe8, 0x10, 0xba, 0x00, 0xa8, 0x59, 0xae, 0x95, 0x2a, 0xbc, 0x58,
	0xab, 0x17, 0x79, 0xf1, 0x8e, 0x50, 0x6e, 0xf1, 0x02, 0x4d, 0xa1, 0x55, 0x58, 0xb6, 0xd3, 0x05,
	0x3e, 0x5f, 0xe4, 0x05, 0xb1, 0x5e, 0xab, 0xdc, 0xa5, 0xc3, 0x88, 0x81, 0x0b, 0xd5, 0x76, 0xa5,
	0x55, 0xf6, 0xb6, 0x45, 0xd0, 0x1a, 0x64, 0x6d, 0x6d, 0x44, 0x07, 0x51, 0x1b, 0xd5, 0xd5, 0xda,
	0x5a, 0x8d, 0x9f, 0xa4, 0x71, 0x8e, 0xd5, 0x20, 0x61, 0x62, 0x82, 0xbe, 0x08, 0x31, 0xec, 0x70,
	0x33, 0xa9, 0x2d, 0x59, 0x70, 0x71, 0xbb, 0x98, 0x6e, 0xac, 0x77, 0xc2, 0xc4, 0xbc, 0x00, 0x29,
	0x1b, 0x79, 0xa6, 0x75, 0xfe, 0x0e, 0x05, 0x0b, 0x4e, 0xa4, 0xd1, 0x75, 0x97, 0xf1, 0x55, 0x97,
	0x2b, 0xce, 0xba, 0x0b, 0xef, 0x52, 0x90, 0x29, 0xca, 0x7d, 0xf9, 0xf3, 0x84, 0xee, 0x27, 0x21,
	0x69, 0xc6, 0x8a, 0x2e, 0x99, 0x7f, 0xb6, 0xa9, 0x95, 0x20, 0x71, 0xa2, 0x8b, 0x6e, 0xc2, 0x79,
	0xc2, 0x67, 0xcd, 0xb3, 0x88, 0xff, 0x3c, 0x5b, 0x38, 0x74, 0x7c, 0xb3, 0xdf, 0xa2, 0x60, 0xd1,
	0xd9, 0xbb, 0xc0, 0x40, 0xe8, 0xc7, 0x36, 0x7b, 0x20, 0x4c, 0x98, 0x81, 0x70, 0x1c, 0xda, 0x3e,
	0xa1, 0x20, 0x57, 0x18, 0x0e, 0x34, 0x65, 0xd8, 0xef, 0xcb, 0x4a, 0xe3, 0xe0, 0x5e, 0xbf, 0xa7,
	0x3e, 0x78, 0x0c, 0xc1, 0x42, 0x1b, 0x10, 0x1f, 0x0c, 0xbb, 0x58, 0xbf, 0xb1, 0xce, 0xe3, 0x5c,
	0x6d, 0xd8, 0xd5, 0xb5, 0xc7, 0x74, 0x7a, 0xb9, 0x8b, 0x18, 0x48, 0x28, 0xb2, 0xd4, 0x1d, 0x0e,
	0xfa, 0x47, 0x78, 0xa5, 0x27, 0x04, 0xeb, 0x9b, 0xfd, 0x07, 0x05, 0xeb, 0x81, 0xc3, 0x24, 0xa8,
	0xe7, 0x5d, 0xa8, 0x7f, 0x81, 0x9b, 0x22, 0x31, 0xbb, 0x03, 0x2a, 0x56, 0x26, 0xda, 0x82, 0xcc,
	0xc8, 0xd0, 0x29, 0x7a, 0x33, 0x12, 0xe2, 0x1c, 0xf6, 0x70, 0x62, 0x4a, 0x8f, 0xdc, 0xa4, 0xb1,
	0x13, 0x47, 0x10, 0x33, 0xb0, 0x40, 0xd7, 0x5c, 0x0b, 0x2c, 0x43, 0x40, 0x3a, 0xeb, 0x85, 0xf5,
	0x1d, 0x0a, 0xd2, 0x9e, 0x3e, 0xea, 0xf3, 0xd6, 0x61, 0x3d, 0xe7, 0x1d, 0xc7, 0x59, 0x77, 0xe4,
	0x03, 0x0a, 0x36, 0xc6, 0x6e, 0x6a, 0x0f, 0x46, 0xff, 0xc7, 0x33, 0x58, 0x0f, 0x57, 0x97, 0x26,
	0x0c, 0x86, 0xcc, 0xd3, 0x82, 0x6b, 0x9e, 0x3e, 0xc5, 0x4d, 0x95, 0x39, 0x93, 0x50, 0xf1, 0x1b,
	0x0a, 0x2e, 0xed, 0x4a, 0xfd, 0x5e, 0xd7, 0x2a, 0xc9, 0xec, 0xb5, 0xe5, 0x2c, 0x58, 0xbb, 0xca,
	0xb0, 0xf0, 0xc4, 0x32, 0x2c, 0xa8, 0xf0, 0x8d, 0xcc, 0x50, 0xf8, 0xb2, 0x7f, 0xa3, 0x80, 0x9d,
	0xd4, 0x77, 0x02, 0x6d, 0xd1, 0x05, 0xed, 0xd3, 0xdc, 0x74, 0xa1, 0xd9, 0xb1, 0xbd, 0x6d, 0x45,
	0x81, 0x35, 0x48, 0x5a, 0x3b, 0x49, 0x6c, 0x32, 0x21, 0x8c, 0x09, 0x28, 0x0b, 0xf1, 0x7d, 0x59,
	0x55, 0xa5, 0x3d, 0x73, 0xde, 0x9b, 0x9f, 0x63, 0x9f, 0xbc, 0x43, 0x01, 0xaa, 0xf4, 0x54, 0x52,
	0x07, 0xce, 0xe4, 0x04, 0xbd, 0x34, 0x94, 0xde, 0x12, 0xe5, 0x81, 0xa6, 0xf4, 0x48, 0xe1, 0x36,
	0x2f, 0xc0, 0xbe, 0xf4, 0x16, 0x6f, 0x50, 0xf4, 0x4a, 0x4d, 0xd5, 0x24, 0x45, 0xeb, 0x0d, 0xf6,
	0x44, 0x6d, 0xf8, 0x50, 0x1e, 0xe0, 0x89, 0x9e, 0x14, 0xe6, 0x4d, 0x6a, 0x4b, 0x27, 0xb2, 0x3f,
	0x0c, 0x43, 0xc6, 0xd1, 0x05, 0x82, 0xe5, 0x0d, 0x17, 0x96, 0xab, 0x9c, 0x0f, 0xd7, 0xec, 0xe0,
	0xbd, 0x3b, 0xde, 0x62, 0xbe, 0x08, 0x71, 0xb3, 0xf7, 0x46, 0xbc, 0xb9, 0x34, 0xc1, 0x04, 0x67,
	0x84, 0x1c, 0x53, 0x02, 0x5d, 0x04, 0x18, 0xc8, 0x6f, 0x69, 0x64, 0x64, 0x06, 0xbe, 0x49, 0x9d,
	0x82, 0x47, 0xc5, 0xdc, 0x80, 0x39, 0x23, 0x18, 0x7d, 0xce, 0x2d, 0xc3, 0x4d, 0x40, 0x25, 0x59,
	0xb3, 0x2a, 0xea, 0x19, 0xb6, 0xed, 0x3f, 0xa7, 0x20, 0xe3, 0x10, 0x0d, 0xc4, 0xd3, 0x87, 0x6b,
	0x76, 0x3c, 0xbf, 0x64, 0xc1, 0x79, 0x05, 0x16, 0xb4, 0xa1, 0x26, 0xf5, 0x45, 0xb3, 0x12, 0x37,
	0x2b, 0x73, 0x4c, 0x35, 0x2d, 0x8d, 0x87, 0xb8, 0x6d, 0x8f, 0xbc, 0xa4, 0x2f, 0x9f, 0x23, 0x1a,
	0xb0, 0x1f, 0x3b, 0xa2, 0x9e, 0x47, 0xd1, 0x09, 0xa2, 0x5e, 0x80, 0xcc, 0xec, 0x60, 0xbc, 0x62,
	0x81, 0x71, 0x1b, 0xce, 0x39, 0xa2, 0x4d, 0x18, 0x4f, 0xb0, 0x35, 0x9b, 0xd1, 0xa6, 0xac, 0x1c,
	0xf6, 0x3a, 0xf6, 0xc0, 0xe3, 0x90, 0x18, 0xe3, 0xf4, 0xe7, 0x30, 0xac, 0x4e, 0x10, 0x43, 0xcf,
	0x42, 0x44, 0x19, 0x75, 0xc8, 0xb0, 0x36, 0x26, 0x59, 0xe0, 0x84, 0x46, 0x61, 0x27, 0x24, 0xe8,
	0xec, 0xe8, 0x36, 0xa4, 0xdd, 0x51, 0xf1, 0x88, 0x0c, 0xcb, 0x1b, 0x13, 0x77, 0x42, 0x02, 0xed,
	0x8a, 0x8a, 0x47, 0xcc, 0xaf, 0x29, 0x88, 0x08, 0x8d, 0x02, 0x7a, 0x01, 0xa2, 0xd6, 0xce, 0x71,
	0x61, 0xf3, 0xca, 0xb4, 0x0e, 0x70, 0xfa, 0xc6, 0x52, 0xc0, 0x22, 0xec, 0x10, 0xa2, 0x78, 0x9b,
	0xe9, 0xd8, 0xf9, 0x64, 0x61, 0xb1, 0x20, 0xf0, 0xf9, 0x16, 0x2f, 0x16, 0xf9, 0x0a, 0xdf, 0xe2,
	0xc5, 0xdd, 0x7a, 0xa5, 0x5d, 0xe5, 0x69, 0x4a, 0xdf, 0xc2, 0x34, 0xda, 0x5b, 0x95, 0x72, 0x73,
	0x47, 0x6c, 0xd7, 0xcc, 0x5f, 0xa4, 0x35, 0x8c, 0x68, 0x38, 0x57, 0x29, 0x37, 0x5b, 0x84, 0xd0,
	0xa4, 0x23, 0x3a, 0xa5, 0xc4, 0xb7, 0xc4, 0x42, 0xbe, 0x91, 0x2f, 0x94, 0x5b, 0x77, 0xe9, 0xe8,
	0x56, 0xcc, 0xe8, 0x2b, 0xfb, 0x28, 0x0c, 0x59, 0x3d, 0x79, 0x3e, 0xc6, 0x05, 0x6b, 0x40, 0x85,
	0x17, 0x9d, 0xa1, 0xc2, 0xd3, 0x63, 0xb4, 0x26, 0x29, 0x7b, 0xb2, 0x26, 0x8e, 0x24, 0xed, 0x01,
	0xae, 0x6a, 0x93, 0x02, 0x18, 0xa4, 0x86, 0xa4, 0x3d, 0x40, 0x2f, 0xfb, 0xcd, 0x82, 0x58, 0xc0,
	0x2c, 0xf0, 0xce, 0x01, 0x47, 0xcd, 0x1c, 0x77, 0xd5, 0xcc, 0xdf, 0xa3, 0x60, 0xc5, 0x07, 0x63,
	0xb2, 0x1e, 0x5f, 0x74, 0xad, 0xc7, 0x4b, 0x5c, 0x20, 0xef, 0x99, 0x54, 0x1f, 0xbf, 0xa3, 0x80,
	0xd1, 0x2d, 0x3c, 0xd6, 0x25, 0x9e, 0xcb, 0x5f, 0x51, 0xb7, 0xbf, 0xd8, 0xef, 0x53, 0xb0, 0xea,
	0x3b, 0x0a, 0x82, 0xea, 0x4b, 0x2e, 0x54, 0x9f, 0xe0, 0x26, 0x70, 0x9f, 0x09, 0xae, 0xcf, 0x01,
	0x5d, 0x92, 0x35, 0x52, 0x88, 0xce, 0x10, 0xb5, 0x7f, 0x4c, 0x41, 0xda, 0x26, 0x48, 0xfa, 0x7f,
	0xdd, 0xd5, 0xff, 0x15, 0xce, 0xc3, 0x33, 0x7b, 0xaf, 0x9f, 0xb6, 0xa2, 0xb2, 0xad, 0x84, 0xa6,
	0x7c, 0x4b, 0x68, 0xc7, 0xb8, 0x1a, 0xca, 0xf0, 0x9e, 0xac, 0xb7, 0xcf, 0x32, 0xae, 0xb7, 0x21,
	0x6d, 0x93, 0x0b, 0x1c, 0x96, 0x87, 0xe7, 0x4c, 0x9c, 0x71, 0xdb, 0x98, 0xe3, 0xa7, 0x48, 0xa6,
	0x1f, 0x92, 0x09, 0x16, 0x94, 0x46, 0xfd, 0x27, 0xd8, 0x99, 0x25, 0xd0, 0xa2, 0xe5, 0xaa, 0x5b,
	0xbe, 0x09, 0xf4, 0x02, 0x36, 0x77, 0xe2, 0xd4, 0x79, 0x4c, 0xc1, 0x92, 0xaf, 0x00, 0xe2, 0xec,
	0x49, 0x93, 0xf1, 0xd7, 0x7a, 0xb6, 0xe9, 0xb2, 0x6e, 0x64, 0xcb, 0xeb, 0x8e, 0x6c, 0xb9, 0x1e,
	0x6c, 0xd9, 0x9e, 0x27, 0x33, 0x3e, 0x79, 0xd2, 0xca, 0x65, 0x7f, 0xb9, 0x04, 0x73, 0x18, 0x46,
	0x74, 0x0b, 0xe6, 0xf7, 0xe4, 0x81, 0xac, 0x48, 0x7d, 0xd1, 0x40, 0xd9, 0x18, 0x5e, 0xc6, 0x40,
	0x99, 0x2b, 0x19, 0x6d, 0x26, 0xe4, 0xe7, 0xf6, 0x6c, 0xdf, 0xe8, 0x15, 0xc8, 0x74, 0xf0, 0x69,
	0xb9, 0x99, 0x6d, 0xec, 0x7e, 0xca, 0x12, 0x0d, 0xf6, 0xf3, 0x74, 0x53, 0x4d, 0xba, 0xe3, 0x26,
	0xea, 0xba, 0xba, 0xf8, 0xc0, 0xc9, 0xa9, 0x2b, 0xe2, 0xd0, 0x65, 0x3f, 0x92, 0xb2, 0x74, 0x75,
	0xdd, 0x44, 0x74, 0x04, 0x4f, 0x76, 0xac, 0x82, 0x42, 0x74, 0x65, 0x44, 0x87, 0xfa, 0x28, 0x99,
	0x90, 0xa4, 0xab, 0xfe, 0x67, 0x2f, 0xa6, 0x25, 0xb6, 0xe3, 0xdf, 0x6e, 0x37, 0xfd, 0x4d, 0xb8,
	0x6a, 0x33, 0x7d, 0x30, 0x98, 0x64, 0xdc, 0x38, 0x1a, 0xbe, 0xe2, 0x31, 0xee, 0x0a, 0xbd, 0xa6,
	0xf9, 0xcb, 0x9d, 0x20, 0x0e, 0x7b, 0x07, 0x0e, 0x80, 0x3d, 0x24, 0xfb, 0x47, 0xd1, 0x67, 0x0b,
	0x4b, 0x4c, 0x1b, 0xe9, 0xfa, 0x49, 0x62, 0x3a, 0x78, 0xc3, 0x69, 0xda, 0x5e, 0x3f, 0x9c, 0xcc,
	0x82, 0x5e, 0x87, 0x15, 0x1c, 0x25, 0x5d, 0xe3, 0x35, 0xac, 0xc5, 0xc9, 0xb5, 0x83, 0x61, 0xcd,
	0x93, 0xb3, 0x4d, 0x23, 0x17, 0x06, 0xbe, 0x2d, 0xe8, 0xeb, 0xb0, 0x8a, 0x75, 0x7b, 0xd0, 0x34,
	0xb4, 0x27, 0xb0, 0xf6, 0x75, 0x9b, 0xf6, 0x00, 0x00, 0xb3, 0x83, 0x80, 0x36, 0x94, 0x07, 0x7a,
	0xa4, 0x07, 0x57, 0x11, 0xdb, 0x31, 0xd4, 0x26, 0xb1, 0xda, 0x25, 0xa2, 0xd6, 0x8a, 0xbd, 0xa6,
	0xb2, 0x85, 0x91, 0x83, 0xc2, 0xfc, 0x34, 0x0c, 0xe7, 0xec, 0x8b, 0x05, 0x15, 0x00, 0xb0, 0x22,
	0xb1, 0x33, 0x3e, 0xce, 0xbf, 0xec, 0xb3, 0xaa, 0x1c, 0x1f, 0x05, 0x3d, 0xba, 0x27, 0x65, 0xf3,
	0x27, 0xfa, 0x32, 0x2c, 0x75, 0x24, 0x3c, 0x95, 0xf6, 0x0f, 0x54, 0x4d, 0x1c, 0x0c, 0x35, 0x51,
	0x91, 0x35, 0xc5, 0x08, 0x23, 0x09, 0x01, 0x19, 0x8d, 0xd5, 0x03, 0x55, 0xab, 0x0d, 0x35, 0x41,
	0x6f, 0x41, 0xd7, 0x20, 0x6d, 0xd8, 0xed, 0xca, 0x6a, 0x47, 0xe9, 0x8d, 0x34, 0x3d, 0x76, 0x1b,
	0xbb, 0x68, 0x1a, 0x37, 0x14, 0xc7, 0x74, 0xf6, 0xa1, 0x9e, 0x89, 0x9d, 0xe6, 0x9d, 0x85, 0xf5,
	0x3c, 0x24, 0xdb, 0xb5, 0x22, 0xbf, 0x5d, 0xae, 0xf1, 0x45, 0x9a, 0x42, 0xeb, 0xb0, 0xda, 0xae,
	0x35, 0xdb, 0x8d, 0x46, 0x5d, 0x68, 0xf1, 0x45, 0x51, 0xe0, 0xbf, 0xda, 0xe6, 0xf5, 0xf2, 0x99,
	0x17, 0x9a, 0xe5, 0x7a, 0x8d, 0xdc, 0x26, 0x94, 0x9b, 0xcd, 0x72, 0xad, 0x84, 0x1b, 0xcb, 0x02,
	0x5f, 0x14, 0xb7, 0xcb, 0x7c, 0xa5, 0x48, 0x47, 0x98, 0x6f, 0x47, 0x20, 0xed, 0x89, 0x06, 0xa8,
	0xea, 0x83, 0x13, 0x17, 0x14, 0x3b, 0xbc, 0x14, 0x37, 0x62, 0xbe, 0xc3, 0x0f, 0x07, 0x0c, 0xff,
	0x33, 0x0a, 0x96, 0x7c, 0x35, 0x7a, 0x77, 0x17, 0xf9, 0x4a, 0x45, 0xac, 0xd5, 0x5b, 0x62, 0xb9,
	0xda, 0xa8, 0xf0, 0x55, 0xbe, 0xd6, 0xc2, 0x78, 0x6c, 0xc0, 0x5a, 0xbd, 0xc1, 0x0b, 0xf9, 0x56,
	0xb9, 0x5e, 0x13, 0x1b, 0x7c, 0xad, 0xa8, 0x0f, 0x7c, 0xbb, 0x2e, 0x8c, 0x77, 0x18, 0xcb, 0x90,
	0x29, 0xd7, 0x76, 0xf3, 0x95, 0x72, 0x91, 0xd0, 0xc4, 0x5a, 0xbe, 0xca, 0xd3, 0x11, 0x94, 0x03,
	0xc6, 0x0e, 0xa5, 0xb9, 0xe1, 0x10, 0x85, 0x7c, 0xad, 0xc4, 0xd3, 0x51, 0xb4, 0x02, 0x4b, 0x44,
	0x20, 0x5f, 0x11, 0xf8, 0x7c, 0xf1, 0xae, 0xc8, 0xbf, 0x56, 0x6e, 0xb6, 0x9a, 0xf4, 0x1c, 0xba,
	0x08, 0x2b, 0x76, 0xd1, 0x46, 0x5e, 0xc8, 0x57, 0xf9, 0x16, 0x2f, 0x88, 0xaf, 0xf2, 0x77, 0xe9,
	0x18, 0x5a, 0x85, 0x65, 0xd3, 0xe4, 0xb8, 0x69, 0x37, 0x5f, 0x69, 0xf3, 0x74, 0x9c, 0xf9, 0x6d,
	0x18, 0xd2, 0x9e, 0x30, 0x3a, 0xd1, 0x09, 0x1e, 0x6e, 0x2f, 0xe5, 0x54, 0x4e, 0x78, 0x9f, 0x82,
	0x25, 0x5f, 0x8d, 0x67, 0xe7, 0x84, 0x25, 0x48, 0xbb, 0x9c, 0x50, 0x2e, 0xd2, 0x11, 0x3b, 0x50,
	0x84, 0x5c, 0xe5, 0x5b, 0xf9, 0x62, 0xbe, 0x95, 0x77, 0xe0, 0x5f, 0xac, 0xf3, 0x4d, 0x6c, 0x16,
	0x3b, 0x80, 0x9e, 0x63, 0xfe, 0x19, 0x81, 0xb5, 0x49, 0xb9, 0x02, 0x75, 0x7c, 0xe0, 0x2c, 0x9e,
	0x20, 0xc9, 0x4c, 0x6c, 0x3c, 0x0d, 0xc8, 0x88, 0x85, 0x04, 0xa9, 0x62, 0xcd, 0x53, 0x4c, 0xab,
	0x8c, 0x8d, 0x1b, 0x65, 0xac, 0xca, 0x7e, 0x37, 0x6c, 0x3f, 0x5d, 0xf1, 0xef, 0xc0, 0xe3, 0xea,
	0x13, 0x5d, 0xce, 0xb5, 0x5c, 0xf2, 0xad, 0x56, 0xbe, 0xb0, 0xc3, 0x17, 0xe9, 0x98, 0xbe, 0x08,
	0xf1, 0x1d, 0xa5, 0x4b, 0x2a, 0x8e, 0x2e, 0x00, 0xaa, 0xe6, 0x5f, 0xb3, 0x58, 0xf1, 0x4d, 0x66,
	0x93, 0x4e, 0x30, 0x9f, 0x44, 0xec, 0x57, 0x54, 0xbe, 0x39, 0x63, 0xcf, 0xc7, 0xc7, 0x3b, 0x27,
	0xca, 0xe5, 0x53, 0x9a, 0x4f, 0xb5, 0x98, 0x7e, 0x15, 0x06, 0x76, 0xba, 0xfa, 0xc7, 0xd6, 0x8b,
	0x01, 0x8e, 0x8a, 0xa1, 0x0c, 0x9c, 0x37, 0x15, 0x62, 0x86, 0x72, 0x91, 0x8e, 0xa3, 0xa7, 0xe0,
	0x8a, 0x19, 0x53, 0xeb, 0xad, 0xb1, 0x13, 0x5b, 0x75, 0xb1, 0xd9, 0xe0, 0x0b, 0xe5, 0xed, 0x32,
	0xf1, 0x28, 0x9d, 0x40, 0x8b, 0x40, 0x13, 0x39, 0x2b, 0x2f, 0xd1, 0x49, 0xe6, 0xe3, 0x30, 0xac,
	0x4f, 0x29, 0x7e, 0x50, 0xcf, 0xc7, 0xcf, 0xaf, 0x9c, 0xac, 0x70, 0x9a, 0xd6, 0x7e, 0x2a, 0x4f,
	0xbf, 0x47, 0xc1, 0x13, 0x27, 0xd0, 0xef, 0x74, 0x75, 0x20, 0xf4, 0xf8, 0xa0, 0xcc, 0x9e, 0x54,
	0xaa, 0xf5, 0x76, 0xad, 0x25, 0xd6, 0x1b, 0x2d, 0x23, 0xaf, 0xaf, 0xc2, 0xb2, 0xbd, 0x95, 0x28,
	0x69, 0xdd, 0x6d, 0xe8, 0xa9, 0x6c, 0x19, 0x32, 0xf6, 0xc6, 0xed, 0xa6, 0xd1, 0x10, 0x65, 0xfe,
	0x1b, 0x86, 0x0b, 0xfe, 0xe5, 0x1e, 0xba, 0xe3, 0x03, 0xeb, 0xcd, 0x89, 0x15, 0x62, 0x00, 0xf9,
	0x54, 0x20, 0x7e, 0x48, 0x4e, 0x78, 0x4e, 0x12, 0xec, 0xa6, 0x2d, 0x06, 0x2a, 0x18, 0xdd, 0xf0,
	0x44, 0x74, 0x23, 0x93, 0xd0, 0x8d, 0x06, 0xa1, 0x3b, 0x87, 0xce, 0x43, 0xca, 0xd0, 0xc3, 0x0b,
	0x42, 0x5d, 0xa0, 0x63, 0xcc, 0x7b, 0xe4, 0x84, 0xd2, 0x37, 0x5e, 0x7d, 0xcd, 0x07, 0xf0, 0xaf,
	0x4c, 0x29, 0x9a, 0x03, 0x1b, 0x4e, 0x05, 0xfa, 0xdb, 0xb0, 0x36, 0x49, 0xef, 0x19, 0xa2, 0x9e,
	0x86, 0xf9, 0x76, 0xcd, 0x8e, 0x51, 0x84, 0xf9, 0x0f, 0x05, 0x0b, 0xce, 0x62, 0x1e, 0x95, 0x7c,
	0x90, 0xb9, 0xea, 0x5b, 0xf7, 0xbb, 0x3e, 0x4f, 0x85, 0xc2, 0x1b, 0x80, 0xbc, 0xda, 0x9c, 0x63,
	0x5f, 0x82, 0xf4, 0x56, 0xbe, 0x28, 0x36, 0x2a, 0xed, 0x52, 0xb9, 0x26, 0x16, 0xea, 0xb5, 0xed,
	0x72, 0x89, 0xa6, 0xd0, 0x65, 0xd8, 0xf0, 0xd4, 0xd8, 0x3b, 0xf5, 0x66, 0x4b, 0x2c, 0xf2, 0x3a,
	0x40, 0x7c, 0xad, 0x70, 0x97, 0x0e, 0xe3, 0x81, 0x5a, 0x07, 0x61, 0xd3, 0x07, 0xea, 0x64, 0x75,
	0x7d, 0x9e, 0x76, 0xa0, 0x5e, 0x6d, 0x67, 0x37, 0x50, 0xeb, 0x39, 0xd9, 0xe6, 0xcf, 0x28, 0x48,
	0x94, 0xbb, 0xf2, 0x40, 0xeb, 0x69, 0x47, 0xa8, 0x8d, 0x5f, 0xb1, 0x7a, 0xde, 0xeb, 0xa2, 0x35,
	0x6e, 0xc2, 0xab, 0x60, 0xe6, 0xe2, 0xc4, 0x47, 0xbe, 0x6c, 0x08, 0xdd, 0x86, 0x79, 0xc7, 0xb3,
	0x50, 0xb4, 0xc4, 0xf9, 0x3d, 0x96, 0x65, 0x2e, 0xf8, 0xbf, 0x1e, 0x65, 0x43, 0x9b, 0x3f, 0x9a,
	0x03, 0x18, 0x67, 0x68, 0xf4, 0x12, 0x9c, 0xb3, 0xef, 0x40, 0xd0, 0xa2, 0xdf, 0xd3, 0x48, 0x66,
	0xc9, 0xf7, 0x59, 0x22, 0x1b, 0xd2, 0xc5, 0xed, 0xb5, 0x33, 0x5a, 0xe4, 0x7c, 0xde, 0x1e, 0x31,
	0x4b, 0xbe, 0x8f, 0x79, 0xd8, 0x10, 0x7a, 0x03, 0x96, 0x03, 0x2a, 0x3e, 0xb4, 0xce, 0x4d, 0x7e,
	0xa3, 0xc3, 0x6c, 0x4c, 0x7b, 0xab, 0xc2, 0x86, 0x50, 0x17, 0x56, 0x02, 0xab, 0x11, 0x74, 0x89,
	0x9b, 0xf6, 0x8a, 0x82, 0x61, 0xa7, 0xbf, 0x33, 0x60, 0x43, 0x68, 0x0f, 0x98, 0xe0, 0x4c, 0x88,
	0x58, 0x6e, 0xea, 0x0b, 0x02, 0xe6, 0x89, 0x13, 0x5c, 0xba, 0xb3, 0x21, 0x74, 0x0b, 0x52, 0xb6,
	0xdb, 0x5e, 0x94, 0xe1, 0xbc, 0xf7, 0xe0, 0xcc, 0xa2, 0xdf, 0x85, 0xb0, 0x21, 0x6b, 0xbb, 0x3c,
	0x45, 0x19, 0xce, 0x7b, 0x57, 0xcb, 0x2c, 0xfa, 0xdd, 0xaf, 0xba, 0x61, 0x74, 0x1d, 0x9c, 0x3a,
	0x60, 0xf4, 0x3f, 0xc5, 0x75, 0xc0, 0x18, 0x70, 0xee, 0xca, 0x86, 0x36, 0x3f, 0x0d, 0x43, 0x54,
	0x5f, 0xa6, 0xa8, 0x02, 0x69, 0x4f, 0x52, 0x44, 0x2b, 0x5c, 0xd0, 0xe5, 0x17, 0xc3, 0x04, 0xdf,
	0xc3, 0xb0, 0x21, 0x24, 0x40, 0xc6, 0x27, 0xdc, 0xa3, 0x55, 0x2e, 0xf8, 0x6a, 0x85, 0x59, 0x9b,
	0x74, 0x07, 0xc1, 0x86, 0xd0, 0xb3, 0x90, 0xb4, 0x62, 0x0a, 0x4a, 0x73, 0xee, 0xdb, 0x04, 0x06,
	0x79, 0xef, 0x00, 0x0c, 0x29, 0x2b, 0xe4, 0xa2, 0x34, 0xe7, 0x3e, 0xab, 0x67, 0x90, 0xf7, 0x88,
	0x7d, 0xdc, 0x7f, 0x37, 0xec, 0xab, 0x5c, 0xf0, 0xb1, 0x39, 0xe9, 0x7f, 0x20, 0xd4, 0x5b, 0xcf,
	0x7e, 0xf4, 0x28, 0x17, 0xfa, 0xfb, 0xa3, 0x5c, 0xe8, 0xb3, 0x47, 0x39, 0xea, 0x9d, 0xe3, 0x1c,
	0xf5, 0x8b, 0xe3, 0x1c, 0xf5, 0x87, 0xe3, 0x1c, 0xf5, 0xd1, 0x71, 0x8e, 0xfa, 0xd7, 0x71, 0x8e,
	0xfa, 0xf4, 0x38, 0x17, 0xfa, 0xec, 0x38, 0x47, 0xfd, 0xe0, 0xdf, 0xb9, 0xd0, 0xeb, 0xb1, 0x8e,
	0xda, 0xeb, 0x1f, 0xee, 0xdf, 0x8b, 0xe1, 0x7f, 0x36, 0x5c, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x37, 0x4c, 0x22, 0xfd, 0xe6, 0x30, 0x00, 0x00,
}
